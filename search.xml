<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>æœºè¯•æ¨¡æ¿æ•´ç†</title>
      <link href="/code-template/"/>
      <url>/code-template/</url>
      
        <content type="html"><![CDATA[<blockquote><p>è¿™æ˜¯å½“æ—¶æˆ‘å»å‚åŠ æ¸…åè®¡ç®—æœºç³»å¤ä»¤è¥æ—¶ä¸ºæœºè€ƒå‡†å¤‡çš„æ¨¡æ¿ï¼Œéƒ¨åˆ†<a href="#å‚è€ƒ">å‚è€ƒé“¾æ¥</a>åœ¨æœ€ååˆ—å‡ºã€‚æœ€åæœºè¯•çš„æ—¶å€™å®é™…åªç”¨åˆ°äº†å…³äºå¼ºè¿é€šåˆ†é‡ç¼©ç‚¹çš„é‚£éƒ¨åˆ†ä»£ç ï¼Œè¯´èµ·æ¥é‚£éƒ¨åˆ†ä»£ç è¿˜æ˜¯æœºè¯•å‰ä¸€å¤©æ™šä¸Šåœ¨å®¾é¦†æ‰‹æŠ„çš„ï¼ˆæœç„¶æˆ‘æ€»èƒ½è€ƒå‰ç²¾å‡†æŠ¼é¢˜233333ï¼‰ã€‚</p><p>ä»Šå¹´æ¸…åæœºè¯•ä¸€åå¸¸æ€éš¾åº¦å¤§å¤§é™ä½ï¼Œæ»¡åˆ†çš„ä¼¼ä¹éƒ½æœ‰25%ï¼Œæˆ‘å½“æ—¶åœ¨æµ‹è¯•æ•°æ®ä¸Šä¹Ÿæ˜¯å–å¾—äº†æ»¡åˆ†ï¼ˆä¹‹åæœ‰ç©ºæŠŠåŸé¢˜ä¹Ÿæ•´ç†ä¸€ä¸‹æ”¾ä¸Šæ¥ï¼‰ã€‚ä¸è¿‡æœ€åå› ä¸ºå…¶ä»–ä¸€äº›åŸå› ï¼Œä¹Ÿæ²¡æœ‰å»æŠ¥åæ¸…åä¹æœˆçš„æ¨å…ï¼Œä¹Ÿå°±æ²¡èƒ½å»æˆæ¸…åã€‚ä¸è¿‡è¿™äº›ç®—æ³•æ¨¡æ¿ä½œä¸ºå­¦ä¹ ææ–™è¿˜æ˜¯å¾ˆä¸é”™çš„ï¼ˆè¯´ä¸å®šä»¥åä»€ä¹ˆæ—¶å€™åˆç”¨ä¸Šäº†ï¼‰ã€‚</p></blockquote><h1 id="0-å¤´æ–‡ä»¶"><a href="#0-å¤´æ–‡ä»¶" class="headerlink" title="0. å¤´æ–‡ä»¶"></a>0. å¤´æ–‡ä»¶</h1><pre class=" language-c++"><code class="language-c++">#define _CRT_SBCURE_NO_DEPRECATE#include < set>#include < cmath>#include < queue>#include < stack>#include < vector>#include < string>#include < cstdio>#include < cstdlib>#include < cstring>#include < iostream>#include < algorithm>#include < functional>using namespace std;const int maxn = 110;const int INF = 0x3f3f3f3f;</code></pre><h1 id="1-ç»å…¸ç®—æ³•"><a href="#1-ç»å…¸ç®—æ³•" class="headerlink" title="1. ç»å…¸ç®—æ³•"></a>1. ç»å…¸ç®—æ³•</h1><h2 id="1-1-åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•"><a href="#1-1-åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•" class="headerlink" title="1.1. åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•"></a>1.1. åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•</h2><pre class=" language-c++"><code class="language-c++">/*    |åŸƒå¼ç­›æ³•|    |å¿«é€Ÿç­›é€‰ç´ æ•°|*/int prime[maxn];  bool is_prime[maxn];int sieve(int n){    int p = 0;    for(int i = 0; i <= n; ++i)        is_prime[i] = true;    is_prime[0] = is_prime[1] = false;    for (int i = 2; i <= n; ++i){   //  æ³¨æ„æ•°ç»„å¤§å°æ˜¯n        if(is_prime[i]){            prime[p++] = i;            for(int j = i + i; j <= n; j += i)  //  è½»å‰ªæï¼Œjå¿…å®šæ˜¯içš„å€æ•°                is_prime[j] = false;        }    }    return p;   //  è¿”å›ç´ æ•°ä¸ªæ•°}</code></pre><h2 id="1-2-å¿«é€Ÿå¹‚"><a href="#1-2-å¿«é€Ÿå¹‚" class="headerlink" title="1.2. å¿«é€Ÿå¹‚"></a>1.2. å¿«é€Ÿå¹‚</h2><pre class=" language-c++"><code class="language-c++">typedef long long LL;   //  è§†æ•°æ®å¤§å°çš„æƒ…å†µè€Œå®šLL powerMod(LL x, LL n, LL m){    LL res = 1;    while (n > 0){        if  (n & 1) //  åˆ¤æ–­æ˜¯å¦ä¸ºå¥‡æ•°ï¼Œè‹¥æ˜¯åˆ™true            res = (res * x) % m;        x = (x * x) % m;        n >>= 1;    //  ç›¸å½“äºn /= 2;    }    return res;}</code></pre><h2 id="1-3-å¤§æ•°æ¨¡æ‹Ÿ"><a href="#1-3-å¤§æ•°æ¨¡æ‹Ÿ" class="headerlink" title="1.3. å¤§æ•°æ¨¡æ‹Ÿ"></a>1.3. å¤§æ•°æ¨¡æ‹Ÿ</h2><h3 id="1-3-1-å¤§æ•°åŠ æ³•"><a href="#1-3-1-å¤§æ•°åŠ æ³•" class="headerlink" title="1.3.1. å¤§æ•°åŠ æ³•"></a>1.3.1. å¤§æ•°åŠ æ³•</h3><pre class=" language-c++"><code class="language-c++">/*    |å¤§æ•°æ¨¡æ‹ŸåŠ æ³•|    |ç”¨stringæ¨¡æ‹Ÿ|*/string add1(string s1, string s2){    if (s1 == "" && s2 == "")   return "0";    if (s1 == "")   return s2;    if (s2 == "")   return s1;    string maxx = s1, minn = s2;    if (s1.length() < s2.length()){        maxx = s2;        minn = s1;    }    int a = maxx.length() - 1, b = minn.length() - 1;    for (int i = b; i >= 0; --i){        maxx[a--] += minn[i] - '0'; //  aä¸€ç›´åœ¨å‡ ï¼Œ é¢å¤–è¿˜è¦å‡ä¸ª'0'    }    for (int i = maxx.length()-1; i > 0;--i){        if (maxx[i] > '9'){            maxx[i] -= 10;//æ³¨æ„è¿™ä¸ªæ˜¯å‡10            maxx[i - 1]++;        }    }    if (maxx[0] > '9'){        maxx[0] -= 10;        maxx = '1' + maxx;    }    return maxx;}</code></pre><h3 id="1-3-2-å¤§æ•°é˜¶ä¹˜"><a href="#1-3-2-å¤§æ•°é˜¶ä¹˜" class="headerlink" title="1.3.2. å¤§æ•°é˜¶ä¹˜"></a>1.3.2. å¤§æ•°é˜¶ä¹˜</h3><pre class=" language-c++"><code class="language-c++">/*    |å¤§æ•°æ¨¡æ‹Ÿé˜¶ä¹˜||ç”¨æ•°ç»„æ¨¡æ‹Ÿ|*/#include <iostream>#include <cstdio>using namespace std;typedef long long LL;const int maxn = 100010;int num[maxn], len;/*    åœ¨multå‡½æ•°ä¸­ï¼Œå½¢å‚éƒ¨åˆ†ï¼šlenæ¯æ¬¡è°ƒç”¨å‡½æ•°éƒ½ä¼šå‘ç”Ÿæ”¹å˜ï¼Œnè¡¨ç¤ºæ¯æ¬¡è¦ä¹˜ä»¥çš„æ•°ï¼Œæœ€ç»ˆè¿”å›çš„æ˜¯ç»“æœçš„é•¿åº¦    tip: é˜¶ä¹˜éƒ½æ˜¯å…ˆæ±‚ä¹‹å‰çš„(n-1)!æ¥æ±‚n!    åˆå§‹åŒ–Initå‡½æ•°å¾ˆé‡è¦ï¼Œä¸è¦è½ä¸‹*/void Init() {    len = 1;    num[0] = 1;}int mult(int num[], int len, int n) {    LL tmp = 0;    for(LL i = 0; i < len; ++i) {         tmp = tmp + num[i] * n;    //ä»æœ€ä½ä½å¼€å§‹ï¼Œç­‰å·å·¦è¾¹çš„tmpè¡¨ç¤ºå½“å‰ä½ï¼Œå³è¾¹çš„tmpè¡¨ç¤ºè¿›ä½ï¼ˆä¹‹å‰è¿›çš„ä½ï¼‰         num[i] = tmp % 10; //  ä¿å­˜åœ¨å¯¹åº”çš„æ•°ç»„ä½ç½®ï¼Œå³å»æ‰è¿›ä½åçš„ä¸€ä½æ•°         tmp = tmp / 10;    //  å–æ•´ç”¨äºå†æ¬¡å¾ªç¯,ä¸nå’Œä¸‹ä¸€ä¸ªä½ç½®çš„ä¹˜ç§¯ç›¸åŠ     }    while(tmp) {    //  ä¹‹åçš„è¿›ä½å¤„ç†         num[len++] = tmp % 10;         tmp = tmp / 10;    }    return len;}int main() {    Init();    int n;    n = 1977; // æ±‚çš„é˜¶ä¹˜æ•°    for(int i = 2; i <= n; ++i) {        len = mult(num, len, i);    }    for(int i = len - 1; i >= 0; --i)        printf("%d",num[i]);    //  ä»æœ€é«˜ä½ä¾æ¬¡è¾“å‡º,æ•°æ®æ¯”è¾ƒå¤šé‡‡ç”¨printfè¾“å‡º    printf("\n");    return 0;}</code></pre><h2 id="1-4-æœ€å¤§å…¬çº¦æ•°ï¼ˆGCDï¼‰"><a href="#1-4-æœ€å¤§å…¬çº¦æ•°ï¼ˆGCDï¼‰" class="headerlink" title="1.4. æœ€å¤§å…¬çº¦æ•°ï¼ˆGCDï¼‰"></a>1.4. æœ€å¤§å…¬çº¦æ•°ï¼ˆGCDï¼‰</h2><pre class=" language-c++"><code class="language-c++">/*    |è¾—è½¬ç›¸é™¤æ³•|    |æ¬§å‡ é‡Œå¾—ç®—æ³•||æ±‚æœ€å¤§å…¬çº¦æ•°|*/int gcd(int big, int small){    if (small > big)         swap(big, small);    int temp;    while (small != 0){ //  è¾—è½¬ç›¸é™¤æ³•        if (small > big)             swap(big, small);        temp = big % small;        big = small;        small = temp;    }    return(big);}</code></pre><h2 id="1-5-æœ€å°å…¬å€æ•°ï¼ˆLCMï¼‰"><a href="#1-5-æœ€å°å…¬å€æ•°ï¼ˆLCMï¼‰" class="headerlink" title="1.5. æœ€å°å…¬å€æ•°ï¼ˆLCMï¼‰"></a>1.5. æœ€å°å…¬å€æ•°ï¼ˆLCMï¼‰</h2><pre class=" language-c++"><code class="language-c++">int lcm (int big, int small) {    return big * small / gcd(big, small);}</code></pre><h2 id="1-6-å…¨æ’åˆ—"><a href="#1-6-å…¨æ’åˆ—" class="headerlink" title="1.6. å…¨æ’åˆ—"></a>1.6. å…¨æ’åˆ—</h2><pre class=" language-c++"><code class="language-c++">/*    |æ±‚1åˆ°nçš„å…¨æ’åˆ—, æœ‰æ¡ä»¶|*/void Pern(int list[], int k, int n) {   //  kè¡¨ç¤ºå‰kä¸ªæ•°ä¸åŠ¨ä»…ç§»åŠ¨åé¢n-kä½æ•°    if (k == n - 1) {        for (int i = 0; i < n; i++) {            printf("%d", list[i]);        }        printf("\n");    }    else {        for (int i = k; i < n; i++) {   //  è¾“å‡ºçš„æ˜¯æ»¡è¶³ç§»åŠ¨æ¡ä»¶æ‰€æœ‰å…¨æ’åˆ—            swap(list[k], list[i]);            Pern(list, k + 1, n);            swap(list[k], list[i]);        }    }}</code></pre><h2 id="1-7-äºŒåˆ†æœç´¢"><a href="#1-7-äºŒåˆ†æœç´¢" class="headerlink" title="1.7. äºŒåˆ†æœç´¢"></a>1.7. äºŒåˆ†æœç´¢</h2><pre class=" language-c++"><code class="language-c++">/*    |äºŒåˆ†æœç´¢|    |è¦æ±‚ï¼šå…ˆæ’åº|*///  leftä¸ºæœ€å¼€å§‹å…ƒç´ , rightæ˜¯æœ«å°¾å…ƒç´ çš„ä¸‹ä¸€ä¸ªæ•°ï¼Œxæ˜¯è¦æ‰¾çš„æ•°int bsearch(int *A, int left, int right, int x){    int m;    while (left < right){        m = left + (right - left) / 2;        if (A[m] >= x)              right = m;           else             left = m + 1;            // å¦‚æœè¦æ›¿æ¢ä¸º upper_bound, æ”¹ä¸º:if (A[m] <= v) x = m+1; else y = m;         }    return left;}/*    æœ€åleft == right      å¦‚æœæ‰¾æœ‰å¤šå°‘çš„xï¼Œå¯ä»¥ç”¨lower_boundæŸ¥æ‰¾ä¸€éï¼Œupper_boundæŸ¥æ‰¾ä¸€éï¼Œä¸‹æ ‡ç›¸å‡ã€‚     C++è‡ªå¸¦çš„lower_bound(a,a+n,x)è¿”å›æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªxçš„åœ°å€, upper_bound(a,a+n,x)è¿”å›æ•°ç»„ä¸­æœ€åä¸€ä¸ªxçš„ä¸‹ä¸€ä¸ªæ•°çš„åœ°å€ã€‚å¦‚æœa+nå†…æ²¡æœ‰æ‰¾åˆ°xæˆ–xçš„ä¸‹ä¸€ä¸ªåœ°å€ï¼Œè¿”å›a+nçš„åœ°å€  */</code></pre><h1 id="2-æ•°æ®ç»“æ„"><a href="#2-æ•°æ®ç»“æ„" class="headerlink" title="2. æ•°æ®ç»“æ„"></a>2. æ•°æ®ç»“æ„</h1><h2 id="2-1-å¹¶æŸ¥é›†"><a href="#2-1-å¹¶æŸ¥é›†" class="headerlink" title="2.1. å¹¶æŸ¥é›†"></a>2.1. å¹¶æŸ¥é›†</h2><pre class=" language-c++"><code class="language-c++">/*    |åˆå¹¶èŠ‚ç‚¹æ“ä½œ|    |16/11/05ztx, thanks to chaixiaojun|*/int father[maxn];   //  å‚¨å­˜içš„fatherçˆ¶èŠ‚ç‚¹  void makeSet() {      for (int i = 0; i < maxn; i++)           father[i] = i;  }  int findRoot(int x) {   //  è¿­ä»£æ‰¾æ ¹èŠ‚ç‚¹    int root = x; // æ ¹èŠ‚ç‚¹      while (root != father[root]) { // å¯»æ‰¾æ ¹èŠ‚ç‚¹          root = father[root];      }      while (x != root) {          int tmp = father[x];          father[x] = root; // æ ¹èŠ‚ç‚¹èµ‹å€¼          x = tmp;      }      return root;  }  int findRoot(int x) {   //  è¿­ä»£æ‰¾æ ¹èŠ‚ç‚¹    if (x == father[x])        return x;    else        return father[x] = findRoot(father[x]);}  void Union(int x, int y) {  //  å°†xæ‰€åœ¨çš„é›†åˆå’Œyæ‰€åœ¨çš„é›†åˆæ•´åˆèµ·æ¥å½¢æˆä¸€ä¸ªé›†åˆã€‚      int a, b;      a = findRoot(x);      b = findRoot(y);      father[a] = b;  // yè¿åœ¨xçš„æ ¹èŠ‚ç‚¹ä¸Š   æˆ–father[b] = aä¸ºxè¿åœ¨yçš„æ ¹èŠ‚ç‚¹ä¸Šï¼›  } </code></pre><h2 id="2-2-æœ€å°ç”Ÿæˆæ ‘"><a href="#2-2-æœ€å°ç”Ÿæˆæ ‘" class="headerlink" title="2.2. æœ€å°ç”Ÿæˆæ ‘"></a>2.2. æœ€å°ç”Ÿæˆæ ‘</h2><h3 id="2-2-1-Kruskalç®—æ³•"><a href="#2-2-1-Kruskalç®—æ³•" class="headerlink" title="2.2.1. Kruskalç®—æ³•"></a>2.2.1. Kruskalç®—æ³•</h3><pre class=" language-c++"><code class="language-c++">/*    |Kruskalç®—æ³•|    |é€‚ç”¨äº ç¨€ç–å›¾ æ±‚æœ€å°ç”Ÿæˆæ ‘|*//*    ç¬¬ä¸€æ­¥ï¼šç‚¹ã€è¾¹ã€åŠ å…¥vectorï¼ŒæŠŠæ‰€æœ‰è¾¹æŒ‰ä»å°åˆ°å¤§æ’åº    ç¬¬äºŒæ­¥ï¼šå¹¶æŸ¥é›†éƒ¨åˆ† + ä¸‹é¢çš„code*/void Kruskal() {        ans = 0;        for (int i = 0; i<len; i++) {            if (Find(edge[i].a) != Find(edge[i].b)) {                Union(edge[i].a, edge[i].b);                ans += edge[i].len;            }        }    } </code></pre><h3 id="2-2-2-Primç®—æ³•"><a href="#2-2-2-Primç®—æ³•" class="headerlink" title="2.2.2. Primç®—æ³•"></a>2.2.2. Primç®—æ³•</h3><pre class=" language-c++"><code class="language-c++">/*    |Primç®—æ³•|    |é€‚ç”¨äº ç¨ å¯†å›¾ æ±‚æœ€å°ç”Ÿæˆæ ‘|    |å †ä¼˜åŒ–ç‰ˆï¼Œæ—¶é—´å¤æ‚åº¦ï¼šO(elgn)|*///ä¼˜å…ˆé˜Ÿåˆ—è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°struct cmp {    bool operator()(int &a, int &b) const {        return a < b;    }};struct node {      int v, len;      node(int v = 0, int len = 0) :v(v), len(len) {}      bool operator < (const node &a)const {  // åŠ å…¥é˜Ÿåˆ—çš„å…ƒç´ è‡ªåŠ¨æŒ‰è·ç¦»ä»å°åˆ°å¤§æ’åº          return len> a.len;      }  };vector<node> G[maxn];int vis[maxn];int dis[maxn];void init() {      for (int i = 0; i<maxn; i++) {          G[i].clear();          dis[i] = INF;          vis[i] = false;      }  } int Prim(int s) {      priority_queue<node>Q; // å®šä¹‰ä¼˜å…ˆé˜Ÿåˆ—      int ans = 0;      Q.push(node(s,0));  // èµ·ç‚¹åŠ å…¥é˜Ÿåˆ—      while (!Q.empty()) {           node now = Q.top(); Q.pop();  // å–å‡ºè·ç¦»æœ€å°çš„ç‚¹          int v = now.v;          if (vis[v]) continue;  // åŒä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¯èƒ½ä¼šæ¨å…¥2æ¬¡æˆ–2æ¬¡ä»¥ä¸Šé˜Ÿåˆ—ï¼Œè¿™æ ·ç¬¬ä¸€ä¸ªè¢«æ ‡è®°åï¼Œå‰©ä¸‹çš„éœ€è¦ç›´æ¥è·³è¿‡ã€‚          vis[v] = true;  // æ ‡è®°ä¸€ä¸‹          ans += now.len;          for (int i = 0; i<G[v].size(); i++) {  // å¼€å§‹æ›´æ–°              int v2 = G[v][i].v;              int len = G[v][i].len;              if (!vis[v2] && dis[v2] > len) {                   dis[v2] = len;                  Q.push(node(v2, dis[v2]));  // æ›´æ–°çš„ç‚¹åŠ å…¥é˜Ÿåˆ—å¹¶æ’åº              }          }      }      return ans; }</code></pre><h2 id="2-3-å•æºæœ€çŸ­è·¯å¾„"><a href="#2-3-å•æºæœ€çŸ­è·¯å¾„" class="headerlink" title="2.3. å•æºæœ€çŸ­è·¯å¾„"></a>2.3. å•æºæœ€çŸ­è·¯å¾„</h2><h3 id="2-3-1-Dijkstraç®—æ³•"><a href="#2-3-1-Dijkstraç®—æ³•" class="headerlink" title="2.3.1. Dijkstraç®—æ³•"></a>2.3.1. Dijkstraç®—æ³•</h3><pre class=" language-c++"><code class="language-c++">/*    |Dijkstraç®—æ³•|    |é€‚ç”¨äºè¾¹æƒä¸ºæ­£çš„æœ‰å‘å›¾æˆ–è€…æ— å‘å›¾|    |æ±‚ä»å•ä¸ªæºç‚¹å‡ºå‘ï¼Œåˆ°æ‰€æœ‰èŠ‚ç‚¹çš„æœ€çŸ­è·¯|    |ä¼˜åŒ–ç‰ˆï¼šæ—¶é—´å¤æ‚åº¦ O(elbn)|*/struct node {      int v, len;      node(int v = 0, int len = 0) :v(v), len(len) {}      bool operator < (const node &a)const {  //  è·ç¦»ä»å°åˆ°å¤§æ’åº          return len > a.len;      }  };  vector<node>G[maxn];  bool vis[maxn];  int dis[maxn];void init() {      for (int i = 0; i<maxn; i++) {          G[i].clear();          vis[i] = false;          dis[i] = INF;      }  } int dijkstra(int s, int e) {      priority_queue<node>Q;      Q.push(node(s, 0)); //  åŠ å…¥é˜Ÿåˆ—å¹¶æ’åº      dis[s] = 0;      while (!Q.empty()) {          node now = Q.top();     //  å–å‡ºå½“å‰æœ€å°çš„          Q.pop();          int v = now.v;          if (vis[v]) continue;   //  å¦‚æœæ ‡è®°è¿‡äº†, ç›´æ¥continue          vis[v] = true;          for (int i = 0; i<G[v].size(); i++) {   //  æ›´æ–°              int v2 = G[v][i].v;              int len = G[v][i].len;              if (!vis[v2] && dis[v2] > dis[v] + len) {                  dis[v2] = dis[v] + len;                  Q.push(node(v2, dis[v2]));              }          }      }      return dis[e];  } </code></pre><h2 id="2-3-2-SPFAç®—æ³•"><a href="#2-3-2-SPFAç®—æ³•" class="headerlink" title="2.3.2. SPFAç®—æ³•"></a>2.3.2. SPFAç®—æ³•</h2><pre class=" language-c++"><code class="language-c++">// æœ€çŸ­è·¯å¾„å¿«é€Ÿç®—æ³•ï¼ˆShortest Path Faster Algorithmï¼‰/*    |SPFAç®—æ³•|    |é˜Ÿåˆ—ä¼˜åŒ–|    |å¯å¤„ç†è´Ÿç¯|*/vector<node> G[maxn];bool inqueue[maxn];int dist[maxn];void Init()  {      for(int i = 0 ; i < maxn ; ++i){          G[i].clear();          dist[i] = INF;      }  }  int SPFA(int s,int e)  {      int v1,v2,weight;      queue<int> Q;      memset(inqueue,false,sizeof(inqueue)); // æ ‡è®°æ˜¯å¦åœ¨é˜Ÿåˆ—ä¸­      memset(cnt,0,sizeof(cnt)); // åŠ å…¥é˜Ÿåˆ—çš„æ¬¡æ•°      dist[s] = 0;      Q.push(s); // èµ·ç‚¹åŠ å…¥é˜Ÿåˆ—      inqueue[s] = true; // æ ‡è®°      while(!Q.empty()){          v1 = Q.front();          Q.pop();          inqueue[v1] = false; // å–æ¶ˆæ ‡è®°          for(int i = 0 ; i < G[v1].size() ; ++i){ // æœç´¢v1çš„é“¾è¡¨              v2 = G[v1][i].vex;              weight = G[v1][i].weight;              if(dist[v2] > dist[v1] + weight){ // æ¾å¼›æ“ä½œ                  dist[v2] = dist[v1] + weight;                  if(inqueue[v2] == false){  // å†æ¬¡åŠ å…¥é˜Ÿåˆ—                      inqueue[v2] = true;                      //cnt[v2]++;  // åˆ¤è´Ÿç¯                      //if(cnt[v2] > n) return -1;                      Q.push(v2);                  } } }      }      return dist[e];  }/*    ä¸æ–­çš„å°†sçš„é‚»æ¥ç‚¹åŠ å…¥é˜Ÿåˆ—ï¼Œå–å‡ºä¸æ–­çš„è¿›è¡Œæ¾å¼›æ“ä½œï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©º      å¦‚æœä¸€ä¸ªç»“ç‚¹è¢«åŠ å…¥é˜Ÿåˆ—è¶…è¿‡n-1æ¬¡ï¼Œé‚£ä¹ˆæ˜¾ç„¶å›¾ä¸­æœ‰è´Ÿç¯  */</code></pre><h3 id="2-3-3-Floydç®—æ³•"><a href="#2-3-3-Floydç®—æ³•" class="headerlink" title="2.3.3. Floydç®—æ³•"></a>2.3.3. Floydç®—æ³•</h3><pre class=" language-c++"><code class="language-c++">/*    |Floydç®—æ³•|    |ä»»æ„ç‚¹å¯¹æœ€çŸ­è·¯ç®—æ³•|    |æ±‚å›¾ä¸­ä»»æ„ä¸¤ç‚¹çš„æœ€çŸ­è·ç¦»çš„ç®—æ³•|*/for (int i = 0; i < n; i++) {   //  åˆå§‹åŒ–ä¸º0      for (int j = 0; j < n; j++)          scanf("%lf", &dis[i][j]);  }for (int k = 0; k < n; k++) {      for (int i = 0; i < n; i++) {          for (int j = 0; j < n; j++) {              dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);          }      }}</code></pre><h2 id="2-4-äºŒåˆ†å›¾"><a href="#2-4-äºŒåˆ†å›¾" class="headerlink" title="2.4. äºŒåˆ†å›¾"></a>2.4. äºŒåˆ†å›¾</h2><h3 id="2-4-1-æŸ“è‰²æ³•"><a href="#2-4-1-æŸ“è‰²æ³•" class="headerlink" title="2.4.1. æŸ“è‰²æ³•"></a>2.4.1. æŸ“è‰²æ³•</h3><pre class=" language-c++"><code class="language-c++">/*    |äº¤å‰æŸ“è‰²æ³•åˆ¤æ–­äºŒåˆ†å›¾|*/int bipartite(int s) {      int u, v;      queue<int>Q;      color[s] = 1;      Q.push(s);      while (!Q.empty()) {          u = Q.front();          Q.pop();          for (int i = 0; i < G[u].size(); i++) {              v = G[u][i];              if (color[v] == 0) {                  color[v] = -color[u];                  Q.push(v);              }              else if (color[v] == color[u])                  return 0;          }      }      return 1;  } </code></pre><h3 id="2-4-2-åŒˆç‰™åˆ©ç®—æ³•"><a href="#2-4-2-åŒˆç‰™åˆ©ç®—æ³•" class="headerlink" title="2.4.2. åŒˆç‰™åˆ©ç®—æ³•"></a>2.4.2. åŒˆç‰™åˆ©ç®—æ³•</h3><pre class=" language-c++"><code class="language-c++">/*    |æ±‚è§£æœ€å¤§åŒ¹é…é—®é¢˜|    |é€’å½’å®ç°|*/vector<int>G[maxn];  bool inpath[maxn];  //  æ ‡è®°  int match[maxn];    //  è®°å½•åŒ¹é…å¯¹è±¡ void init() {      memset(match, -1, sizeof(match));      for (int i = 0; i < maxn; ++i) {          G[i].clear();      }  }bool findpath(int k) {      for (int i = 0; i < G[k].size(); ++i) {          int v = G[k][i];          if (!inpath[v]) {              inpath[v] = true;              if (match[v] == -1 || findpath(match[v])) { // é€’å½’                  match[v] = k; // å³åŒ¹é…å¯¹è±¡æ˜¯â€œkå¦¹å­â€çš„                  return true;              }          }      }      return false;  }  void hungary() {      int cnt = 0;      for (int i = 1; i <= m; i++) {  // mä¸ºéœ€è¦åŒ¹é…çš„â€œå¦¹å­â€æ•°          memset(inpath, false, sizeof(inpath)); // æ¯æ¬¡éƒ½è¦åˆå§‹åŒ–          if (findpath(i)) cnt++;      }      cout << cnt << endl;  }</code></pre><pre class=" language-c++"><code class="language-c++">/*    |æ±‚è§£æœ€å¤§åŒ¹é…é—®é¢˜|    |dfså®ç°|*/int v1, v2;  bool Map[501][501];  bool visit[501];  int link[501];  int result;  bool dfs(int x) {      for (int y = 1; y <= v2; ++y) {          if (Map[x][y] && !visit[y]) {              visit[y] = true;              if (link[y] == 0 || dfs(link[y])) {                  link[y] = x;                  return true;              } } }      return false;  }  void Search()  {      for (int x = 1; x <= v1; x++) {          memset(visit,false,sizeof(visit));          if (dfs(x))              result++;      }}</code></pre><h1 id="3-åŠ¨æ€è§„åˆ’"><a href="#3-åŠ¨æ€è§„åˆ’" class="headerlink" title="3. åŠ¨æ€è§„åˆ’"></a>3. åŠ¨æ€è§„åˆ’</h1><h2 id="3-1-èƒŒåŒ…é—®é¢˜"><a href="#3-1-èƒŒåŒ…é—®é¢˜" class="headerlink" title="3.1. èƒŒåŒ…é—®é¢˜"></a>3.1. èƒŒåŒ…é—®é¢˜</h2><pre class=" language-c++"><code class="language-c++">/*    |01èƒŒåŒ…|    |å®Œå…¨èƒŒåŒ…|    |å¤šé‡èƒŒåŒ…|*///  01èƒŒåŒ…ï¼š  void bag01(int cost,int weight) {      for(i = v; i >= cost; --i)      dp[i] = max(dp[i], dp[i-cost]+weight);  }  //  å®Œå…¨èƒŒåŒ…ï¼š  void complete(int cost, int weight) {      for(i = cost ; i <= v; ++i)      dp[i] = max(dp[i], dp[i - cost] + weight);  }  //  å¤šé‡èƒŒåŒ…ï¼š  void multiply(int cost, int weight, int amount) {      if(cost * amount >= v)          complete(cost, weight);      else{          k = 1;          while (k < amount){              bag01(k * cost, k * weight);              amount -= k;              k += k;          }          bag01(cost * amount, weight * amount);      }  }  </code></pre><h2 id="3-2-æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼ˆLISï¼‰"><a href="#3-2-æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼ˆLISï¼‰" class="headerlink" title="3.2. æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼ˆLISï¼‰"></a>3.2. æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼ˆLISï¼‰</h2><pre class=" language-c++"><code class="language-c++">/*    |æœ€é•¿ä¸Šå‡å­åºåˆ—|    |çŠ¶æ€è½¬ç§»|*//*    çŠ¶æ€è½¬ç§»dp[i] = max{1, dp[j] + 1 };  j<i; a[j]<a[i];    d[i]æ˜¯ä»¥iç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—    ä¸iä¹‹å‰çš„ æ¯ä¸ªa[j]<a[i]çš„ jçš„ä½ç½®çš„æœ€é•¿ä¸Šå‡å­åºåˆ—+1åçš„å€¼æ¯”è¾ƒ*/void solve() {   // å‚è€ƒæŒ‘æˆ˜ç¨‹åºè®¾è®¡å…¥é—¨ç»å…¸;    for(int i = 0; i < n; ++i){          dp[i] = 1;          for(int j = 0; j < i; ++j){              if(a[j] < a[i]){                  dp[i] = max(dp[i], dp[j] + 1);              }        }     }}  /*     ä¼˜åŒ–æ–¹æ³•ï¼š    dp[i]è¡¨ç¤ºé•¿åº¦ä¸ºi+1çš„ä¸Šå‡å­åºåˆ—çš„æœ€æœ«å°¾å…ƒç´       æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ¯”dpæœ«å°¾å¤§çš„æ¥ä»£æ›¿ */void solve() {      for (int i = 0; i < n; ++i){        dp[i] = INF;    }    for (int i = 0; i < n; ++i) {          *lower_bound(dp, dp + n, a[i]) = a[i];  //  è¿”å›ä¸€ä¸ªæŒ‡é’ˆ      }      printf("%d\n", *lower_bound(dp, dp + n, INF) - dp;  }/*      å‡½æ•°lower_bound()è¿”å›ä¸€ä¸ª iterator å®ƒæŒ‡å‘åœ¨[first,last)æ ‡è®°çš„æœ‰åºåºåˆ—ä¸­å¯ä»¥æ’å…¥valueï¼Œè€Œä¸ä¼šç ´åå®¹å™¨é¡ºåºçš„ç¬¬ä¸€ä¸ªä½ç½®ï¼Œè€Œè¿™ä¸ªä½ç½®æ ‡è®°äº†ä¸€ä¸ªä¸å°äºvalueçš„å€¼ã€‚*/</code></pre><h2 id="3-3-æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆLCSï¼‰"><a href="#3-3-æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆLCSï¼‰" class="headerlink" title="3.3. æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆLCSï¼‰"></a>3.3. æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆLCSï¼‰</h2><pre class=" language-c++"><code class="language-c++">/*    |æ±‚æœ€é•¿å…¬å…±å­åºåˆ—|    |é€’æ¨å½¢å¼|*/void solve() {      for (int i = 0; i < n; ++i) {          for (int j = 0; j < m; ++j) {              if (s1[i] == s2[j]) {                  dp[i + 1][j + 1] = dp[i][j] + 1;              }            else {                  dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);              }         }     }}  </code></pre><h1 id="4-å­—ç¬¦ä¸²"><a href="#4-å­—ç¬¦ä¸²" class="headerlink" title="4. å­—ç¬¦ä¸²"></a>4. å­—ç¬¦ä¸²</h1><h2 id="4-1-kmpç®—æ³•"><a href="#4-1-kmpç®—æ³•" class="headerlink" title="4.1. kmpç®—æ³•"></a>4.1. kmpç®—æ³•</h2><pre class=" language-c++"><code class="language-c++">/*    |kmpç®—æ³•|    |å­—ç¬¦ä¸²åŒ¹é…|*/void getnext(char str[maxn], int nextt[maxn]) {    int j = 0, k = -1;    nextt[0] = -1;    while (j < m) {        if (k == -1 || str[j] == str[k]) {            j++;            k++;            nextt[j] = k;        }        else            k = nextt[k];    }}void kmp(int a[maxn], int b[maxn]) {        int nextt[maxm];        int i = 0, j = 0;        getnext(b, nextt);        while (i < n) {            if (j == -1 || a[i] == b[j]) { // æ¯ä¸²ä¸åŠ¨ï¼Œå­ä¸²ç§»åŠ¨                j++;                i++;            }            else {                // iä¸éœ€è¦å›æº¯äº†                // i = i - j + 1;                j = nextt[j];            }            if (j == m) {                printf("%d\n", i - m + 1); // æ¯ä¸²çš„ä½ç½®å‡å»å­ä¸²çš„é•¿åº¦+1                return;            }        }        printf("-1\n");}</code></pre><h2 id="4-2-kmpæ‰©å±•ç®—æ³•"><a href="#4-2-kmpæ‰©å±•ç®—æ³•" class="headerlink" title="4.2. kmpæ‰©å±•ç®—æ³•"></a>4.2. kmpæ‰©å±•ç®—æ³•</h2><pre class=" language-c++"><code class="language-c++">const int MM=100005;    int next[MM],extend[MM];    char S[MM],T[MM];    void GetNext(const char *T) {        int len = strlen(T), a = 0;        next[0] = len;        while(a < len - 1 && T[a] == T[a + 1]) a++;        next[1] = a;        a = 1;        for(int k = 2; k < len; k++) {            int p = a + next[a] - 1, L = next[k - a];            if((k - 1) + L >= p) {                int j = (p - k + 1) > 0 ? (p - k + 1) : 0;                while(k + j < len && T[k + j] == T[j]) j++;                next[k] = j;                a = k;            }        else             next[k] = L;        }    } void GetExtend(const char *S, const char *T) {        GetNext(T);        int slen = strlen(S), tlen = strlen(T), a = 0;        int MinLen = slen < tlen ? slen : tlen;        while(a < MinLen && S[a] == T[a]) a++;        extend[0] = a;         a = 0;        for(int k = 1; k < slen; k++) {            int p = a + extend[a] - 1, L = next[k - a];            if((k - 1) + L >= p) {                int j = (p - k + 1) > 0 ? (p - k + 1) : 0;                while(k + j < slen && j < tlen && S[k + j] == T[j]) j++;                extend[k] = j;                a = k;            }         else                extend[k] = L;        }    }    void show(const int *s,int len){        for(int i = 0; i < len; i++)            cout << s[i] << ' ';        cout << endl;    }    int main() {        while(cin >> S >> T) {            GetExtend(S,T);            show(next,strlen(T));            show(extend,strlen(S));        }        return 0;    }</code></pre><h1 id="5-å­—å…¸æ ‘"><a href="#5-å­—å…¸æ ‘" class="headerlink" title="5. å­—å…¸æ ‘"></a>5. å­—å…¸æ ‘</h1><pre class=" language-c++"><code class="language-c++">struct Trie {      int cnt;      Trie *next[maxn];      Trie(){          cnt = 0;          memset(next,0,sizeof(next));      }  };  Trie *root;  void Insert(char *word) {      Trie *tem = root;      while(*word != '\0') {          int x = *word - 'a';          if(tem->next[x] == NULL)              tem->next[x] = new Trie;          tem = tem->next[x];          tem->cnt++;          word++;      }  }  int Search(char *word) {      Trie *tem = root;      for(int i = 0; word[i] != '\0'; i++) {          int x = word[i]-'a';          if(tem->next[x] == NULL)              return 0;          tem = tem->next[x];      }      return tem->cnt;  }  void Delete(char *word,int t) {      Trie *tem = root;      for(int i = 0; word[i] != '\0'; i++) {          int x = word[i]-'a';          tem = tem->next[x];          (tem->cnt) -= t;      }      for(int i = 0; i < maxn; i++)          tem->next[i] = NULL;  }  int main() {      int n;      char str1[50];      char str2[50];      while(scanf("%d", &n)!=EOF) {          root = new Trie;          while(n--) {              scanf("%s %s",str1,str2);              if(str1[0] == 'i') {                Insert(str2);             }            else if(str1[0] == 's') {                  if(Search(str2))                      printf("Yes\n");                  else                      printf("No\n");              }            else {                  int t = Search(str2);                  if(t)                      Delete(str2,t);              }         }     }      return 0;  }  </code></pre><h1 id="6-çº¿æ®µæ ‘"><a href="#6-çº¿æ®µæ ‘" class="headerlink" title="6. çº¿æ®µæ ‘"></a>6. çº¿æ®µæ ‘</h1><h2 id="6-1-ç‚¹æ›´æ–°"><a href="#6-1-ç‚¹æ›´æ–°" class="headerlink" title="6.1. ç‚¹æ›´æ–°"></a>6.1. ç‚¹æ›´æ–°</h2><pre class=" language-c++"><code class="language-c++">struct node{    int left, right;    int max, sum;};node tree[maxn << 2];int a[maxn];int n;int k = 1;int p, q;string str;void build(int m, int l, int r)//m æ˜¯ æ ‘çš„æ ‡å·{    tree[m].left = l;    tree[m].right = r;    if (l == r) {        tree[m].max = a[l];        tree[m].sum = a[l];        return;    }    int mid = (l + r) >> 1;    build(m << 1, l, mid);    build(m << 1 | 1, mid + 1, r);    tree[m].max = max(tree[m << 1].max, tree[m << 1 | 1].max);    tree[m].sum = tree[m << 1].sum + tree[m << 1 | 1].sum;}void update(int m, int a, int val)//a æ˜¯ èŠ‚ç‚¹ä½ç½®ï¼Œ val æ˜¯ æ›´æ–°çš„å€¼ï¼ˆåŠ å‡çš„å€¼ï¼‰{    if (tree[m].left == a && tree[m].right == a) {        tree[m].max += val;        tree[m].sum += val;        return;    }    int mid = (tree[m].left + tree[m].right) >> 1;    if (a <= mid) {        update(m << 1, a, val);    }    else {        update(m << 1 | 1, a, val);    }    tree[m].max = max(tree[m << 1].max, tree[m << 1 | 1].max);    tree[m].sum = tree[m << 1].sum + tree[m << 1 | 1].sum;}int querySum(int m, int l, int r){    if (l == tree[m].left && r == tree[m].right) {        return tree[m].sum;    }    int mid = (tree[m].left + tree[m].right) >> 1;    if (r <= mid) {        return querySum(m << 1, l, r);    }    else if (l > mid) {        return querySum(m << 1 | 1, l, r);    }    return querySum(m << 1, l, mid) + querySum(m << 1 | 1, mid + 1, r);}int queryMax(int m, int l, int r){    if (l == tree[m].left && r == tree[m].right) {        return tree[m].max;    }    int mid = (tree[m].left + tree[m].right) >> 1;    if (r <= mid) {        return queryMax(m << 1, l, r);    }    else if (l > mid) {        return queryMax(m << 1 | 1, l, r);    }    return max(queryMax(m << 1, l, mid), queryMax(m << 1 | 1, mid + 1, r));} build(1,1,n);  update(1,a,b);  query(1,a,b); </code></pre><h2 id="6-2-åŒºé—´æ›´æ–°"><a href="#6-2-åŒºé—´æ›´æ–°" class="headerlink" title="6.2. åŒºé—´æ›´æ–°"></a>6.2. åŒºé—´æ›´æ–°</h2><pre class=" language-c++"><code class="language-c++">typedef long long ll;  const int maxn = 100010;  int t,n,q;  ll anssum;  struct node{      ll l, r;      ll addv, sum;  }tree[maxn<<2];  void maintain(int id) {      if(tree[id].l >= tree[id].r)          return ;      tree[id].sum = tree[id<<1].sum + tree[id<<1 | 1].sum;  }  void pushdown(int id) {      if(tree[id].l >= tree[id].r)          return ;      if(tree[id].addv){          int tmp = tree[id].addv;          tree[id<<1].addv += tmp;          tree[id<<1|1].addv += tmp;          tree[id<<1].sum += (tree[id<<1].r - tree[id<<1].l + 1) * tmp;          tree[id<<1|1].sum += (tree[id<<1|1].r - tree[id<<1|1].l + 1) * tmp;          tree[id].addv = 0;      }  }  void build(int id,ll l, ll r) {      tree[id].l = l;      tree[id].r = r;      tree[id].addv = 0;      tree[id].sum = 0;      if(l==r) {          tree[id].sum = 0;          return;      }      ll mid = (l+r)>>1;      build(id<<1, l, mid);      build(id<<1 | 1, mid + 1, r);      maintain(id);  }  void updateAdd(int id,ll l,ll r,ll val) {      if(tree[id].l >= l && tree[id].r <= r)      {          tree[id].addv += val;          tree[id].sum += (tree[id].r - tree[id].l + 1) * val;          return;      }      pushdown(id);      ll mid = (tree[id].l + tree[id].r)>>1;      if(l <= mid)          updateAdd(id<<1, l, r, val);      if(mid < r)          updateAdd(id<<1 | 1, l, r, val);      maintain(id);  }  void query(int id, ll l, ll r) {      if(tree[id].l >= l && tree[id].r <= r){          anssum += tree[id].sum;          return;      }      pushdown(id);      ll mid = (tree[id].l + tree[id].r)>>1;      if(l <= mid)          query(id<<1, l, r);      if(mid < r)          query(id<<1 | 1, l, r);      maintain(id);  }  int main() {      scanf("%d", &t);      int kase = 0;      while(t--) {          scanf("%d %d", &n, &q);          build(1, 1, n);          int id;          ll x, y;          ll val;          printf("Case %d:\n", ++kase);          while(q--) {              scanf("%d", &id);              if(id==0) {                  scanf("%lld %lld %lld", &x, &y, &val);                  updateAdd(1, x+1, y+1, val);              }              else {                  scanf("%lld %lld", &x, &y);                  anssum = 0;                  query(1, x+1, y+1);                  printf("%lld\n", anssum);              }         }     }      return 0;  }  </code></pre><h1 id="7-æ ‘çŠ¶æ•°ç»„"><a href="#7-æ ‘çŠ¶æ•°ç»„" class="headerlink" title="7. æ ‘çŠ¶æ•°ç»„"></a>7. æ ‘çŠ¶æ•°ç»„</h1><pre class=" language-c++"><code class="language-c++">typedef long long ll;const int maxn = 50005;int a[maxn];int n;int lowbit(const int t) {    return t & (-t);}void insert(int t, int d) {    while (t <= n){        a[t] += d;        t = t + lowbit(t);    }}ll getSum(int t) {    ll sum = 0;    while (t > 0){        sum += a[t];        t = t - lowbit(t);    }    return sum;}int main() {    int t, k, d;    scanf("%d", &t);    k= 1;    while (t--){        memset(a, 0, sizeof(a));        scanf("%d", &n);        for (int i = 1; i <= n; ++i) {            scanf("%d", &d);            insert(i, d);        }        string str;        printf("Case %d:\n", k++);        while (cin >> str) {            if (str == "End")   break;            int x, y;            scanf("%d %d", &x, &y);            if (str == "Query")                printf("%lld\n", getSum(y) - getSum(x - 1));            else if (str == "Add")                insert(x, y);            else if (str == "Sub")                insert(x, -y);        }    }    return 0;}</code></pre><pre class=" language-c++"><code class="language-c++">// æ±‚é€†åºå¯¹for(int i = 1; i <= n; i++)    {        scanf("%d", &a);        node[i].index = i;        node[i].v = a;    }    sort(node + 1, node + 1 + n);    long long ans=0;    for(int i = 1; i <= n; i++)    {         add(node[i].index);  //ç¦»æ•£åŒ–ç»“æœâ€”â€” ä¸‹æ ‡ç­‰æ•ˆäºæ•°å€¼        ans += i - sum(node[i].index); //å¾—åˆ°ä¹‹å‰æœ‰å¤šå°‘ä¸ªæ¯”ä½ å¤§çš„æ•°ï¼ˆé€†åºå¯¹ï¼‰    }    cout<<ans;</code></pre><h1 id="8-ä¸­å›½å‰©ä½™å®šç†ï¼ˆå­™å­å®šç†ï¼‰"><a href="#8-ä¸­å›½å‰©ä½™å®šç†ï¼ˆå­™å­å®šç†ï¼‰" class="headerlink" title="8. ä¸­å›½å‰©ä½™å®šç†ï¼ˆå­™å­å®šç†ï¼‰"></a>8. ä¸­å›½å‰©ä½™å®šç†ï¼ˆå­™å­å®šç†ï¼‰</h1><pre class=" language-c++"><code class="language-c++">int CRT(int a[],int m[],int n)  {        int M = 1;        int ans = 0;        for(int i=1; i<=n; i++)            M *= m[i];        for(int i=1; i<=n; i++)  {            int x, y;            int Mi = M / m[i];            extend_Euclid(Mi, m[i], x, y);            ans = (ans + Mi * x * a[i]) % M;        }        if(ans < 0) ans += M;        return ans;    }  void extend_Euclid(int a, int b, int &x, int &y)  {      if(b == 0) {          x = 1;          y = 0;          return;      }      extend_Euclid(b, a % b, x, y);      int tmp = x;      x = y;      y = tmp - (a / b) * y;  }  </code></pre><h1 id="9-æœ€å¤§æµ-æœ€å¤§æƒé—­åˆå­å›¾"><a href="#9-æœ€å¤§æµ-æœ€å¤§æƒé—­åˆå­å›¾" class="headerlink" title="9. æœ€å¤§æµ/æœ€å¤§æƒé—­åˆå­å›¾"></a>9. æœ€å¤§æµ/æœ€å¤§æƒé—­åˆå­å›¾</h1><pre class=" language-c++"><code class="language-c++">//ä»æºç‚¹så‘æ¯ä¸ªæ­£æƒç‚¹è¿ä¸€æ¡å®¹é‡ä¸ºæƒå€¼çš„è¾¹ï¼Œæ¯ä¸ªè´Ÿæƒç‚¹å‘æ±‡ç‚¹tè¿ä¸€æ¡å®¹é‡ä¸ºæƒå€¼çš„ç»å¯¹å€¼çš„è¾¹ï¼Œæœ‰å‘å›¾åŸæ¥çš„è¾¹å®¹é‡å…¨éƒ¨ä¸ºæ— é™å¤§ã€‚//æœ€å¤§æƒé—­åˆå­å›¾=ï¼ˆæ­£æƒä¹‹å’Œ-ä¸é€‰çš„æ­£æƒä¹‹å’Œ-è¦é€‰çš„è´Ÿæƒç»å¯¹å€¼ä¹‹å’Œï¼‰=æ­£æƒå€¼å’Œ-æœ€å°å‰²/æœ€å¤§æµ#define maxn 5010     //è¯¾ç¨‹#define maxm 50100    //ç”¨æˆ·#define inf 0x3f3f3f3f  using namespace std;  struct Edge {      int v,c,next;      Edge(int v,int c, int next): v(v), c(c), next(next) {}      Edge(){}  }e[maxm * 6 + maxn * 2];  int p[maxn + maxm];  int cnt, n, m, T;  void init() {      cnt=0;      memset(p, -1, sizeof(p));  } void insert(int u, int v, int c) {      e[cnt] = Edge(v, c, p[u]);      p[u] = cnt++;  // é¡¶ç‚¹uçš„ä¸Šä¸€æ¡ç›¸é‚»çš„è¾¹ } int d[maxn + maxm];  bool bfs() {      memset(d, -1, sizeof(d));      queue<int> q;      d[0] = 0;      q.push(0);      while(!q.empty()) {          int u = q.front();        q.pop();          for(int i = p[u]; i != -1; i = e[i].next) {              int v = e[i].v;              if(e[i].c > 0 && d[v] == -1){                  //printf("%d->%d(%d)\n", u, v, d[u] + 1);                  d[v] = d[u] + 1;                  q.push(v);              }          }      }      return d[T] != -1;  } int dfs(int u, int flow){      if(u == T)        return flow;      int res = 0;      for(int i = p[u]; i != -1; i = e[i].next){          int v = e[i].v;          if(e[i].c > 0 && d[v] == d[u] + 1){              int tmp = dfs(v, min(flow, e[i].c));              e[i].c -= tmp;              flow -= tmp;              e[i^1].c += tmp;              res += tmp;              if(flow == 0)                  break;          }      }      if(res == 0)          d[u] = -1;      return res;  }  int dinic() {      int res = 0;      while(bfs()){     //   printf("here!\n");          res += dfs(0, inf);      }      return res;  }  int main() {      init();      int p, a, b, c, sum=0;      scanf("%d%d", &n, &m);      T = n + m + 1;//æ±‡ç‚¹      for(int i = 1; i <= n; i++){          scanf("%d", &p);          insert(i + m, T, p);  //è¯¾ç¨‹æ”¾å³è¾¹        insert(T, i + m, 0);      }      for(int i = 1; i <= m; i++){          scanf("%d%d%d", &a, &b, &c);          sum += c;          insert(i, a + m, inf);           insert(a + m, i, 0);          insert(i, b + m, inf);          insert(b + m, i, 0);          insert(0, i, c);   //ç”¨æˆ·æ”¾å·¦è¾¹        insert(i, 0, 0);      }      printf("%d\n", sum - dinic());      return 0;  </code></pre><h1 id="10-æ‹“æ‰‘æ’åº-AOEç½‘ç»œ-å…³é”®è·¯å¾„"><a href="#10-æ‹“æ‰‘æ’åº-AOEç½‘ç»œ-å…³é”®è·¯å¾„" class="headerlink" title="10. æ‹“æ‰‘æ’åº/AOEç½‘ç»œ/å…³é”®è·¯å¾„"></a>10. æ‹“æ‰‘æ’åº/AOEç½‘ç»œ/å…³é”®è·¯å¾„</h1><pre class=" language-c++"><code class="language-c++">const int maxn=110;const int INF=1e4;int N,M;struct Node{    //vector<int> child;    int id;     int length;};//Node graph[maxn]; vector<Node> Adj[maxn];//int e[maxn]; //è¾¹ä¸Šæ´»åŠ¨æœ€æ—©å¼€å§‹æ—¶é—´ //int l[maxn]; //è¾¹ä¸Šæ´»åŠ¨æœ€æ™šå¼€å§‹æ—¶é—´int ve[maxn];   //é¡¶ç‚¹ä¸Šæ´»åŠ¨æœ€æ—©å¼€å§‹æ—¶é—´ int vl[maxn];  //é¡¶ç‚¹ä¸Šæ´»åŠ¨æœ€æ™šå¼€å§‹æ—¶é—´int in[maxn];  // æ¯ä¸ªç»“ç‚¹çš„å…¥åº¦ï¼Œä¸º0æ—¶å…¥é˜Ÿstack<int> s;bool TopologicalSort(int N){    queue<int> q;    memset(ve, 0, sizeof(ve));    //memset(inq,0,sizeof(inq));    /*å…ˆæ‰¾å‡ºæ‰€æœ‰åˆå§‹æ—¶å…¥åº¦ä¸º0çš„ç»“ç‚¹*/    for(int i = 1; i <= N; i++)      {        if(in[i] == 0)        {            q.push(i);            //s.push(i);            //inq[i] = true;            //ve[i] = 0;         }    }    /*æ¯æ¬¡å°†æ‰€æœ‰å…¥åº¦ä¸º0çš„ç»“ç‚¹å…¥æ ˆï¼Œæ‹“æ‰‘åº*/    while(!q.empty())    {        int tmp = q.front();        q.pop();            s.push(tmp); // num++ï¼›        //cout << "tmp:" << tmp << endl;        for(int i = 0; i < Adj[tmp].size(); i++)        {            int id = Adj[tmp][i].id;            if(--in[id] == 0) //å…¥åº¦å‡ä¸º0 åŠ å…¥æ‹“æ‰‘æ’åº             {                q.push(id);                //s.push(i);                //inq[i]=true;            }            if(ve[tmp] + Adj[tmp][i].length > ve[id]) //æ›´æ–°veå€¼ >            ve[id] = ve[tmp] + Adj[tmp][i].length;        }     }      //cout<<"size: "<<s.size()<<endl;     if(s.size() == N) return true;     else return false;} void calc_path(int N){    if(TopologicalSort(N) == false)    {        printf("0\n");        return;    }     /*å¯»æ‰¾æ‹“æ‰‘åºåˆ—æœ€åä¸€ä¸ªç»“ç‚¹ï¼Œå³å¼€å§‹æ—¶é—´æœ€æ™šçš„ä¸€ä¸ªç»“ç‚¹*/     int max = -1, u = -1;     for(int i = 1; i <= N; i++)     {         if(ve[i] > max)       {            max = ve[i];            u = i;       }      }      //fill(vl, vl + maxn, INF);       //vl[u] = ve[u];      fill(vl, vl + maxn, ve[u]);       printf("%d\n", ve[u]);     /*å…ƒç´ é€ä¸ªå‡ºæ ˆï¼Œå³ä¸ºé€†æ‹“æ‰‘åºåˆ—ï¼Œæ„é€ vlæ•°ç»„*/     while(!s.empty())     {         int tmp = s.top();         s.pop();         //int min = INF, u;         for(int i = 0; i < Adj[tmp].size(); i++)         {             int id = Adj[tmp][i].id;             if(vl[id] - Adj[tmp][i].length < vl[tmp])             {                 vl[tmp] = vl[id] - Adj[tmp][i].length;             }         }     }     /*éå†é‚»æ¥ç‚¹æ¯æ¡è¾¹ï¼Œè®¡ç®—æ¯é¡¹æ´»åŠ¨çš„æœ€æ—©å’Œæœ€æ™šå¼€å§‹æ—¶é—´*/     for(int i = 1; i <= N; i++)     {         for(int j = Adj[i].size() - 1; j >= 0; j--)         {             int id = Adj[i][j].id;             int e = ve[i];             int l = vl[id]-Adj[i][j].length;             if(e == l) printf("%d->%d\n", i, id);          }     } } int main(){    while(scanf("%d%d", &N, &M) != EOF)    {        int v, w, len;        for(int i = 1; i <= N; i++)        Adj[i].clear();        memset(in, 0, sizeof(in));        for(int i = 0; i < M; i++)        {            scanf("%d%d%d", &v, &w, &len);            Node tmp;            tmp.id = w;            tmp.length = len;            Adj[v].push_back(tmp); //æœ‰å‘å›¾åªè¦æ·»åŠ å•å‘è¾¹å³å¯             in[w]++;         }        while(!s.empty())        s.pop();        calc_path(N);        //cout<<"end!!"<<endl;    }    return 0;}</code></pre><h1 id="11-å¼ºè¿é€šåˆ†é‡"><a href="#11-å¼ºè¿é€šåˆ†é‡" class="headerlink" title="11. å¼ºè¿é€šåˆ†é‡"></a>11. å¼ºè¿é€šåˆ†é‡</h1><pre class=" language-c++"><code class="language-c++">const int N=100010;struct data{    int to, next;} tu[N*2];int head[N];int ip;int dfn[N], low[N];///dfn[]è¡¨ç¤ºæ·±æœçš„æ­¥æ•°ï¼Œlow[u]è¡¨ç¤ºuæˆ–uçš„å­æ ‘èƒ½å¤Ÿè¿½æº¯åˆ°çš„æœ€æ—©çš„æ ˆä¸­èŠ‚ç‚¹çš„æ¬¡åºå·int sccno[N];///ç¼©ç‚¹æ•°ç»„ï¼Œè¡¨ç¤ºæŸä¸ªç‚¹å¯¹åº”çš„ç¼©ç‚¹å€¼int step;int scc_cnt;///å¼ºè¿é€šåˆ†é‡ä¸ªæ•°void init(){    ip=0;    memset(head, -1, sizeof(head));}void add(int u, int v){    tu[ip].to = v;    tu[ip].next = head[u];    head[u] = ip++;}vector<int> scc[N];///å¾—å‡ºæ¥çš„ç¼©ç‚¹ï¼Œscc[i]é‡Œé¢å­˜iè¿™ä¸ªç¼©ç‚¹å…·ä½“ç¼©äº†å“ªäº›ç‚¹stack<int> S;void dfs(int u){    dfn[u] = low[u] = ++step;    S.push(u);    for (int i = head[u]; i != -1; i = tu[i].next)    {        int v = tu[i].to;        if (!dfn[v])        {            dfs(v);            low[u] = min(low[u], low[v]);        }        else if (!sccno[v])            low[u] = min(low[u], dfn[v]);    }    if (low[u] == dfn[u])    {        scc_cnt += 1;        scc[scc_cnt].clear();        while(1)        {            int x = S.top();            S.pop();            if (sccno[x] != scc_cnt) scc[scc_cnt].push_back(x);            sccno[x] = scc_cnt;            if (x == u) break;        }    }}void tarjan(int n){    memset(sccno, 0, sizeof(sccno));    memset(dfn, 0, sizeof(dfn));    step = scc_cnt = 0;    for (int i = 1; i <= n; i++)        if (!dfn[i]) dfs(i);}</code></pre><h1 id="12-æ—¥æœŸæ˜ŸæœŸ"><a href="#12-æ—¥æœŸæ˜ŸæœŸ" class="headerlink" title="12. æ—¥æœŸæ˜ŸæœŸ"></a>12. æ—¥æœŸæ˜ŸæœŸ</h1><pre class=" language-c++"><code class="language-c++">int getDayofWeek(int y, int m, int d){    if(m == 1 || m == 2) {        m += 12;        y--;    }    return (d+2*m+3*(m+1)/5+y+y/4-y/100+y/400+1)%7;} </code></pre><h1 id="å‚è€ƒ"><a href="#å‚è€ƒ" class="headerlink" title="å‚è€ƒ"></a>å‚è€ƒ</h1><ul><li><p><a href="https://blog.csdn.net/qq_32265245/article/details/53046750" target="_blank" rel="noopener">ACMç®—æ³•æ¨¡æ¿</a></p></li><li><p><a href="https://blog.csdn.net/m0_38033475/article/details/80173037" target="_blank" rel="noopener">dinicæ±‚æœ€å¤§æƒé—­åˆå­å›¾</a></p></li><li><p><a href="https://blog.csdn.net/weixin_42584977/article/details/92001428" target="_blank" rel="noopener">æ‹“æ‰‘æ’åº+AOEç½‘ç»œ+å…³é”®è·¯å¾„</a></p></li><li><p><a href="https://blog.csdn.net/martinue/article/details/51315574" target="_blank" rel="noopener">tarjanæ¨¡æ¿</a></p></li><li><p><a href="[https://zh.wikipedia.org/wiki/%E8%94%A1%E5%8B%92%E5%85%AC%E5%BC%8F](https://zh.wikipedia.org/wiki/è”¡å‹’å…¬å¼)">è”¡å‹’å…¬å¼</a></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ç¨‹åºè®¾è®¡ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ä¿ç ” </tag>
            
            <tag> æœºè¯• </tag>
            
            <tag> ç¼–ç¨‹ </tag>
            
            <tag> ç®—æ³• </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ç»ˆäºå¼„å¥½åšå®¢å•¦</title>
      <link href="/first-article/"/>
      <url>/first-article/</url>
      
        <content type="html"><![CDATA[<blockquote><p>åœ¨åä¸€è¿™ä¸€å¤©ï¼Œæ–­æ–­ç»­ç»­åœ°ç»ˆäºæŠŠåšå®¢å»ºå¥½äº†ï¼Œæ„Ÿè°¢è¿™ä½dalaoçš„æ•™ç¨‹<a href="https://zhuanlan.zhihu.com/p/35668237" target="_blank" rel="noopener">è¶…è¯¦ç»†Hexo+Githubåšå®¢æ­å»ºå°ç™½æ•™ç¨‹</a>!</p></blockquote><p>å…¶å®å¼„ä¸ªåšå®¢çš„åˆè¡·è¿˜æ˜¯è‡ªå·±æƒ³å¹³æ—¶å†™ç‚¹ä¸œè¥¿ï¼Œæˆ–è€…æ˜¯è®°å½•ä¸€äº›ç»å†æˆ–è€…æ„Ÿæ‚Ÿï¼Œåˆæˆ–æ˜¯å¹³æ—¶å·¥ä½œå­¦ä¹ æ—¶è®°å½•ä¸€äº›ä¸œè¥¿ã€‚<br>ä¸è¿‡ç›®å‰æ°´å¹³æœ‰é™ï¼Œå¯èƒ½æŠ€æœ¯ä¸Šçš„ä¸œè¥¿æ¯”é‡è¿˜æ˜¯ä¼šåå°‘ä¸€äº›ã€‚ä½†ä¸ç®¡å†™äº›ä»€ä¹ˆï¼Œé‡è¦çš„è¿˜æ˜¯è‡ªå·±è¦å¼€å§‹åšæŒå†™ç‚¹ä¸œè¥¿ã€‚</p><p>æ¥ä¸‹æ¥é¦–å…ˆæƒ³å†™çš„ï¼Œä¸€ä¸ªæ˜¯ä¿ç ”æ–¹é¢çš„ä¸€äº›ç»å†æ„Ÿæ‚Ÿï¼Œå†ä¸€ä¸ªå¯èƒ½å°±æ˜¯å¹³æ—¶çœ‹è®ºæ–‡å†™ä»£ç æ—¶åšçš„ä¸€äº›ç¬”è®°ï¼Œä¹Ÿä¸ç«‹ä»€ä¹ˆflagäº†ï¼Œå°±å¸Œæœ›è¿™ä¸ªåšå®¢èƒ½ä¸€ç›´æ›´æ–°ä¸‹å»å§ã€‚</p><p>æœ€åè¿˜æ˜¯ç¥ç¥–å›½æ¯äº²70å²ç”Ÿæ—¥å¿«ä¹å‘€ï¼ğŸ˜€</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> éšç¬” </category>
          
      </categories>
      
      
        <tags>
            
            <tag> éšç¬” </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

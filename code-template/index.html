<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="水远，怎知流水外，却是乱山尤远。"><title>机试模板整理 | 山尤远</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">机试模板整理</h1><a id="logo" href="/.">山尤远</a><p class="description">THY’s Blog</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">机试模板整理</h1><div class="post-meta">Oct 2, 2019<span> | </span><span class="category"><a href="/categories/程序设计/">程序设计</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 6.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 34</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="code-template/" href="/code-template/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-头文件"><span class="toc-text">0. 头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-经典算法"><span class="toc-text">1. 经典算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-埃拉托斯特尼筛法"><span class="toc-text">1.1. 埃拉托斯特尼筛法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-快速幂"><span class="toc-text">1.2. 快速幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-大数模拟"><span class="toc-text">1.3. 大数模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-大数加法"><span class="toc-text">1.3.1. 大数加法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-大数阶乘"><span class="toc-text">1.3.2. 大数阶乘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-最大公约数（GCD）"><span class="toc-text">1.4. 最大公约数（GCD）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-最小公倍数（LCM）"><span class="toc-text">1.5. 最小公倍数（LCM）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-全排列"><span class="toc-text">1.6. 全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-二分搜索"><span class="toc-text">1.7. 二分搜索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-数据结构"><span class="toc-text">2. 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-并查集"><span class="toc-text">2.1. 并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-最小生成树"><span class="toc-text">2.2. 最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-Kruskal算法"><span class="toc-text">2.2.1. Kruskal算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Prim算法"><span class="toc-text">2.2.2. Prim算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-单源最短路径"><span class="toc-text">2.3. 单源最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-Dijkstra算法"><span class="toc-text">2.3.1. Dijkstra算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-SPFA算法"><span class="toc-text">2.3.2. SPFA算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-Floyd算法"><span class="toc-text">2.3.3. Floyd算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-二分图"><span class="toc-text">2.4. 二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-染色法"><span class="toc-text">2.4.1. 染色法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-匈牙利算法"><span class="toc-text">2.4.2. 匈牙利算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-动态规划"><span class="toc-text">3. 动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-背包问题"><span class="toc-text">3.1. 背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-最长上升子序列（LIS）"><span class="toc-text">3.2. 最长上升子序列（LIS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-最长公共子序列（LCS）"><span class="toc-text">3.3. 最长公共子序列（LCS）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-字符串"><span class="toc-text">4. 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-kmp算法"><span class="toc-text">4.1. kmp算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-kmp扩展算法"><span class="toc-text">4.2. kmp扩展算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-字典树"><span class="toc-text">5. 字典树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-线段树"><span class="toc-text">6. 线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-点更新"><span class="toc-text">6.1. 点更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-区间更新"><span class="toc-text">6.2. 区间更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-树状数组"><span class="toc-text">7. 树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-中国剩余定理（孙子定理）"><span class="toc-text">8. 中国剩余定理（孙子定理）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-最大流-最大权闭合子图"><span class="toc-text">9. 最大流/最大权闭合子图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-拓扑排序-AOE网络-关键路径"><span class="toc-text">10. 拓扑排序/AOE网络/关键路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-强连通分量"><span class="toc-text">11. 强连通分量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-日期与星期-蔡勒公式"><span class="toc-text">12. 日期与星期/蔡勒公式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><blockquote>
<p>这是当时我去参加清华计算机系夏令营时为机考准备的模板，部分参考链接在最后列出, 我整理了我认为常见的一些算法，顺便改了改部分代码风格（其实主要是加空格hhh）。最后机试的时候实际只用到了关于强连通分量缩点的那部分代码，说起来那部分代码还是机试前一天晚上在宾馆手抄的（果然我总能考前精准押题233333）。</p>
<p>今年清华机试一反常态难度大大降低，满分的似乎都有25%，我当时在测试数据上也是取得了满分（之后有空把原题也整理一下放上来）。不过最后因为其他一些原因，也没有去报名清华九月的推免，也就没能去成清华。不过这些算法模板作为学习材料还是很不错的（说不定以后什么时候又用上了）。</p>
</blockquote>
<h2 id="0-头文件"><a href="#0-头文件" class="headerlink" title="0. 头文件"></a>0. 头文件</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SBCURE_NO_DEPRECATE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-经典算法"><a href="#1-经典算法" class="headerlink" title="1. 经典算法"></a>1. 经典算法</h2><h3 id="1-1-埃拉托斯特尼筛法"><a href="#1-1-埃拉托斯特尼筛法" class="headerlink" title="1.1. 埃拉托斯特尼筛法"></a>1.1. 埃拉托斯特尼筛法</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |埃式筛法|</span></span><br><span class="line"><span class="comment">    |快速筛选素数|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> prime[maxn];  </span><br><span class="line"><span class="keyword">bool</span> is_prime[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        is_prime[i] = <span class="literal">true</span>;</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i){   <span class="comment">// 注意数组大小是n</span></span><br><span class="line">        <span class="keyword">if</span>(is_prime[i]){</span><br><span class="line">            prime[p++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)  <span class="comment">// 轻剪枝，j必定是i的倍数</span></span><br><span class="line">                is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p;   <span class="comment">// 返回素数个数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-2-快速幂"><a href="#1-2-快速幂" class="headerlink" title="1.2. 快速幂"></a>1.2. 快速幂</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;   <span class="comment">// 视数据大小的情况而定</span></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">powerMod</span><span class="params">(LL x, LL n, LL m)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>){</span><br><span class="line">        <span class="keyword">if</span>  (n &amp; <span class="number">1</span>) <span class="comment">// 判断是否为奇数，若是则true</span></span><br><span class="line">            res = (res * x) % m;</span><br><span class="line">        x = (x * x) % m;</span><br><span class="line">        n  &gt;&gt;= <span class="number">1</span>;    <span class="comment">// 相当于n /= 2;</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-3-大数模拟"><a href="#1-3-大数模拟" class="headerlink" title="1.3. 大数模拟"></a>1.3. 大数模拟</h3><h4 id="1-3-1-大数加法"><a href="#1-3-1-大数加法" class="headerlink" title="1.3.1. 大数加法"></a>1.3.1. 大数加法</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |大数模拟加法|</span></span><br><span class="line"><span class="comment">    |用string模拟|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">add1</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="string">""</span> &amp;&amp; s2 == <span class="string">""</span>)   <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="string">""</span>)   <span class="keyword">return</span> s2;</span><br><span class="line">    <span class="keyword">if</span> (s2 == <span class="string">""</span>)   <span class="keyword">return</span> s1;</span><br><span class="line">    <span class="built_in">string</span> maxx = s1, minn = s2;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() &lt; s2.length()){</span><br><span class="line">        maxx = s2;</span><br><span class="line">        minn = s1;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> a = maxx.length() - <span class="number">1</span>, b = minn.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &gt;= <span class="number">0</span>; --i){</span><br><span class="line">        maxx[a--] += minn[i] - <span class="string">'0'</span>; <span class="comment">// a一直在减 ， 额外还要减个'0'</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = maxx.length()<span class="number">-1</span>; i &gt; <span class="number">0</span>;--i){</span><br><span class="line">        <span class="keyword">if</span> (maxx[i] &gt; <span class="string">'9'</span>){</span><br><span class="line">            maxx[i] -= <span class="number">10</span>;<span class="comment">//注意这个是减10</span></span><br><span class="line">            maxx[i - <span class="number">1</span>]++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (maxx[<span class="number">0</span>] &gt; <span class="string">'9'</span>){</span><br><span class="line">        maxx[<span class="number">0</span>] -= <span class="number">10</span>;</span><br><span class="line">        maxx = <span class="string">'1'</span> + maxx;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxx;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="1-3-2-大数阶乘"><a href="#1-3-2-大数阶乘" class="headerlink" title="1.3.2. 大数阶乘"></a>1.3.2. 大数阶乘</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |大数模拟阶乘|</span></span><br><span class="line"><span class="comment">|用数组模拟|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> num[maxn], len;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在mult函数中，形参部分：len每次调用函数都会发生改变，n表示每次要乘以的数，最终返回的是结果的长度</span></span><br><span class="line"><span class="comment">    tip: 阶乘都是先求之前的(n-1)!来求n!</span></span><br><span class="line"><span class="comment">    初始化Init函数很重要，不要落下</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>{</span><br><span class="line">    len = <span class="number">1</span>;</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mult</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> len, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    LL tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; len; ++i) {</span><br><span class="line">         tmp = tmp + num[i] * n;    <span class="comment">//从最低位开始，等号左边的tmp表示当前位，右边的tmp表示进位（之前进的位）</span></span><br><span class="line">         num[i] = tmp % <span class="number">10</span>; <span class="comment">// 保存在对应的数组位置，即去掉进位后的一位数</span></span><br><span class="line">         tmp = tmp / <span class="number">10</span>;    <span class="comment">// 取整用于再次循环,与n和下一个位置的乘积相加</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(tmp) {    <span class="comment">// 之后的进位处理</span></span><br><span class="line">         num[len++] = tmp % <span class="number">10</span>;</span><br><span class="line">         tmp = tmp / <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    n = <span class="number">1977</span>; <span class="comment">// 求的阶乘数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) {</span><br><span class="line">        len = mult(num, len, i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,num[i]);    <span class="comment">// 从最高位依次输出,数据比较多采用printf输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-4-最大公约数（GCD）"><a href="#1-4-最大公约数（GCD）" class="headerlink" title="1.4. 最大公约数（GCD）"></a>1.4. 最大公约数（GCD）</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |辗转相除法|</span></span><br><span class="line"><span class="comment">    |欧几里得算法|</span></span><br><span class="line"><span class="comment">	|求最大公约数|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> big, <span class="keyword">int</span> small)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (small &gt; big) </span><br><span class="line">        swap(big, small);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (small != <span class="number">0</span>){ <span class="comment">// 辗转相除法</span></span><br><span class="line">        <span class="keyword">if</span> (small &gt; big) </span><br><span class="line">            swap(big, small);</span><br><span class="line">        temp = big % small;</span><br><span class="line">        big = small;</span><br><span class="line">        small = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>(big);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-5-最小公倍数（LCM）"><a href="#1-5-最小公倍数（LCM）" class="headerlink" title="1.5. 最小公倍数（LCM）"></a>1.5. 最小公倍数（LCM）</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span> <span class="params">(<span class="keyword">int</span> big, <span class="keyword">int</span> small)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> big * small / gcd(big, small);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-6-全排列"><a href="#1-6-全排列" class="headerlink" title="1.6. 全排列"></a>1.6. 全排列</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |求1到n的全排列, 有条件|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pern</span><span class="params">(<span class="keyword">int</span> <span class="built_in">list</span>[], <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>{   <span class="comment">// k表示前k个数不动仅移动后面n-k位数</span></span><br><span class="line">    <span class="keyword">if</span> (k == n - <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="built_in">list</span>[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; i++) {   <span class="comment">// 输出的是满足移动条件所有全排列</span></span><br><span class="line">            swap(<span class="built_in">list</span>[k], <span class="built_in">list</span>[i]);</span><br><span class="line">            Pern(<span class="built_in">list</span>, k + <span class="number">1</span>, n);</span><br><span class="line">            swap(<span class="built_in">list</span>[k], <span class="built_in">list</span>[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-7-二分搜索"><a href="#1-7-二分搜索" class="headerlink" title="1.7. 二分搜索"></a>1.7. 二分搜索</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |二分搜索|</span></span><br><span class="line"><span class="comment">    |要求：先排序|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// left为最开始元素, right是末尾元素的下一个数，x是要找的数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right){</span><br><span class="line">        m = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[m] &gt;= x)  </span><br><span class="line">            right = m;   </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            left = m + <span class="number">1</span>;    </span><br><span class="line">        <span class="comment">// 如果要替换为 upper_bound, 改为 if (A[m] &lt;= v) x = m+1; else y = m;     </span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    最后left == right  </span></span><br><span class="line"><span class="comment">    如果找有多少的x，可以用lower_bound查找一遍，upper_bound查找一遍，下标相减。 </span></span><br><span class="line"><span class="comment">    cpp自带的lower_bound(a,a+n,x)返回数组中第一个x的地址, upper_bound(a,a+n,x)返回数组中最后一个x的下一个数的地址。如果a+n内没有找到x或x的下一个地址，返回a+n的地址  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><h3 id="2-1-并查集"><a href="#2-1-并查集" class="headerlink" title="2.1. 并查集"></a>2.1. 并查集</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |合并节点操作|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> father[maxn];   <span class="comment">// 储存i的father父节点  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSet</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)   </span><br><span class="line">        father[i] = i;  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{   <span class="comment">// 迭代找根节点</span></span><br><span class="line">    <span class="keyword">int</span> root = x; <span class="comment">// 根节点  </span></span><br><span class="line">    <span class="keyword">while</span> (root != father[root]) { <span class="comment">// 寻找根节点  </span></span><br><span class="line">        root = father[root];  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">while</span> (x != root) {  </span><br><span class="line">        <span class="keyword">int</span> tmp = father[x];  </span><br><span class="line">        father[x] = root; <span class="comment">// 根节点赋值  </span></span><br><span class="line">        x = tmp;  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{   <span class="comment">// 迭代找根节点</span></span><br><span class="line">	<span class="keyword">if</span> (x == father[x])</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> father[x] = findRoot(father[x]);</span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{  <span class="comment">// 将x所在的集合和y所在的集合整合起来形成一个集合。  </span></span><br><span class="line">    <span class="keyword">int</span> a, b;  </span><br><span class="line">    a = findRoot(x);  </span><br><span class="line">    b = findRoot(y);  </span><br><span class="line">    father[a] = b;  <span class="comment">// y连在x的根节点上   或father[b] = a为x连在y的根节点上；  </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-最小生成树"><a href="#2-2-最小生成树" class="headerlink" title="2.2. 最小生成树"></a>2.2. 最小生成树</h3><h4 id="2-2-1-Kruskal算法"><a href="#2-2-1-Kruskal算法" class="headerlink" title="2.2.1. Kruskal算法"></a>2.2.1. Kruskal算法</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |Kruskal算法|</span></span><br><span class="line"><span class="comment">    |适用于稀疏图|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一步：点、边、加入vector，把所有边按从小到大排序</span></span><br><span class="line"><span class="comment">    第二步：并查集部分 + 下面的code</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>{    </span><br><span class="line">    ans = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {    </span><br><span class="line">        <span class="keyword">if</span> (Find(edge[i].a) != Find(edge[i].b)) {    </span><br><span class="line">            Union(edge[i].a, edge[i].b);    </span><br><span class="line">            ans += edge[i].len;    </span><br><span class="line">        }    </span><br><span class="line">    }    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-2-2-Prim算法"><a href="#2-2-2-Prim算法" class="headerlink" title="2.2.2. Prim算法"></a>2.2.2. Prim算法</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |Prim算法|</span></span><br><span class="line"><span class="comment">    |适用于稠密图|</span></span><br><span class="line"><span class="comment">    |堆优化版，时间复杂度：O(elgn)|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//优先队列自定义比较函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> {</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> a &lt; b;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span>  </span><br><span class="line">    <span class="keyword">int</span> v, len;  </span><br><span class="line">    node(<span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> len = <span class="number">0</span>) :v(v), len(len) {}  </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> {  <span class="comment">// 加入队列的元素自动按距离从小到大排序  </span></span><br><span class="line">        <span class="keyword">return</span> len &gt; a.len;  </span><br><span class="line">    }  </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) {  </span><br><span class="line">        G[i].clear();  </span><br><span class="line">        dis[i] = INF;  </span><br><span class="line">        vis[i] = <span class="literal">false</span>;  </span><br><span class="line">    }  </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{  </span><br><span class="line">    priority_queue&lt;node&gt; Q; <span class="comment">// 定义优先队列  </span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;  </span><br><span class="line">    Q.push(node(s,<span class="number">0</span>));  <span class="comment">// 起点加入队列  </span></span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) {   </span><br><span class="line">        node now = Q.top(); </span><br><span class="line">		Q.pop();  <span class="comment">// 取出距离最小的点  </span></span><br><span class="line">        <span class="keyword">int</span> v = now.v;  </span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;  <span class="comment">// 同一个节点，可能会推入2次或2次以上队列，这样第一个被标记后，剩下的需要直接跳过。  </span></span><br><span class="line">        vis[v] = <span class="literal">true</span>;  <span class="comment">// 标记一下  </span></span><br><span class="line">        ans += now.len;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++) {  <span class="comment">// 开始更新  </span></span><br><span class="line">            <span class="keyword">int</span> v2 = G[v][i].v;  </span><br><span class="line">            <span class="keyword">int</span> len = G[v][i].len;  </span><br><span class="line">            <span class="keyword">if</span> (!vis[v2] &amp;&amp; dis[v2] &gt; len) {   </span><br><span class="line">                dis[v2] = len;  </span><br><span class="line">                Q.push(node(v2, dis[v2]));  <span class="comment">// 更新的点加入队列并排序  </span></span><br><span class="line">            }  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-3-单源最短路径"><a href="#2-3-单源最短路径" class="headerlink" title="2.3. 单源最短路径"></a>2.3. 单源最短路径</h3><h4 id="2-3-1-Dijkstra算法"><a href="#2-3-1-Dijkstra算法" class="headerlink" title="2.3.1. Dijkstra算法"></a>2.3.1. Dijkstra算法</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |Dijkstra算法|</span></span><br><span class="line"><span class="comment">    |适用于边权为正的有向图或者无向图|</span></span><br><span class="line"><span class="comment">    |求从单个源点出发，到所有节点的最短路|</span></span><br><span class="line"><span class="comment">    |优化版：时间复杂度 O(elbn)|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span>  </span><br><span class="line">    <span class="keyword">int</span> v, len;  </span><br><span class="line">    node(<span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> len = <span class="number">0</span>) :v(v), len(len) {}  </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> {  <span class="comment">// 距离从小到大排序  </span></span><br><span class="line">        <span class="keyword">return</span> len &gt; a.len;  </span><br><span class="line">    }  </span><br><span class="line">};  </span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;G[maxn];  </span><br><span class="line"><span class="keyword">bool</span> vis[maxn];  </span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;maxn; i++) {  </span><br><span class="line">        G[i].clear();  </span><br><span class="line">        vis[i] = <span class="literal">false</span>;  </span><br><span class="line">        dis[i] = INF;  </span><br><span class="line">    }  </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>{  </span><br><span class="line">    priority_queue&lt;node&gt; Q;  </span><br><span class="line">    Q.push(node(s, <span class="number">0</span>)); <span class="comment">// 加入队列并排序  </span></span><br><span class="line">    dis[s] = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) {  </span><br><span class="line">        node now = Q.top();     <span class="comment">// 取出当前最小的  </span></span><br><span class="line">        Q.pop();  </span><br><span class="line">        <span class="keyword">int</span> v = now.v;  </span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;   <span class="comment">// 如果标记过了, 直接continue  </span></span><br><span class="line">        vis[v] = <span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++) {   <span class="comment">// 更新  </span></span><br><span class="line">            <span class="keyword">int</span> v2 = G[v][i].v;  </span><br><span class="line">            <span class="keyword">int</span> len = G[v][i].len;  </span><br><span class="line">            <span class="keyword">if</span> (!vis[v2] &amp;&amp; dis[v2] &gt; dis[v] + len) {  </span><br><span class="line">                dis[v2] = dis[v] + len;  </span><br><span class="line">                Q.push(node(v2, dis[v2]));  </span><br><span class="line">            }  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> dis[e];  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-3-2-SPFA算法"><a href="#2-3-2-SPFA算法" class="headerlink" title="2.3.2. SPFA算法"></a>2.3.2. SPFA算法</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最短路径快速算法（Shortest Path Faster Algorithm）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |SPFA算法|</span></span><br><span class="line"><span class="comment">    |队列优化|</span></span><br><span class="line"><span class="comment">    |可处理负环|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; G[maxn];</span><br><span class="line"><span class="keyword">bool</span> inqueue[maxn];</span><br><span class="line"><span class="keyword">int</span> dist[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>{  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i){  </span><br><span class="line">        G[i].clear();  </span><br><span class="line">        dist[i] = INF;  </span><br><span class="line">    }  </span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span>  </span></span><br><span class="line"><span class="function"></span>{  </span><br><span class="line">    <span class="keyword">int</span> v1, v2, weight;  </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;  </span><br><span class="line">    <span class="built_in">memset</span>(inqueue, <span class="literal">false</span>, <span class="keyword">sizeof</span>(inqueue)); <span class="comment">// 标记是否在队列中  </span></span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt)); <span class="comment">// 加入队列的次数  </span></span><br><span class="line">    dist[s] = <span class="number">0</span>;  </span><br><span class="line">    Q.push(s); <span class="comment">// 起点加入队列  </span></span><br><span class="line">    inqueue[s] = <span class="literal">true</span>; <span class="comment">// 标记  </span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()){  </span><br><span class="line">        v1 = Q.front();  </span><br><span class="line">        Q.pop();  </span><br><span class="line">        inqueue[v1] = <span class="literal">false</span>; <span class="comment">// 取消标记  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v1].size(); ++i){ <span class="comment">// 搜索v1的链表  </span></span><br><span class="line">            v2 = G[v1][i].vex;  </span><br><span class="line">            weight = G[v1][i].weight;  </span><br><span class="line">            <span class="keyword">if</span>(dist[v2] &gt; dist[v1] + weight){ <span class="comment">// 松弛操作  </span></span><br><span class="line">                dist[v2] = dist[v1] + weight;  </span><br><span class="line">                <span class="keyword">if</span>(inqueue[v2] == <span class="literal">false</span>){  <span class="comment">// 再次加入队列  </span></span><br><span class="line">                    inqueue[v2] = <span class="literal">true</span>;  </span><br><span class="line">                    <span class="comment">//cnt[v2]++;  // 判负环  </span></span><br><span class="line">                    <span class="comment">//if(cnt[v2] &gt; n) return -1;  </span></span><br><span class="line">                    Q.push(v2);  </span><br><span class="line">                } } }  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> dist[e];  </span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    不断的将s的邻接点加入队列，取出不断的进行松弛操作，直到队列为空  </span></span><br><span class="line"><span class="comment">    如果一个结点被加入队列超过n-1次，那么显然图中有负环  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-3-3-Floyd算法"><a href="#2-3-3-Floyd算法" class="headerlink" title="2.3.3. Floyd算法"></a>2.3.3. Floyd算法</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |Floyd算法|</span></span><br><span class="line"><span class="comment">    |任意点对最短路算法|</span></span><br><span class="line"><span class="comment">    |求图中任意两点的最短距离的算法|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {   <span class="comment">// 初始化为0  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;dis[i][j]);  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) {  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {  </span><br><span class="line">            dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);  </span><br><span class="line">        }  </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-4-二分图"><a href="#2-4-二分图" class="headerlink" title="2.4. 二分图"></a>2.4. 二分图</h3><h4 id="2-4-1-染色法"><a href="#2-4-1-染色法" class="headerlink" title="2.4.1. 染色法"></a>2.4.1. 染色法</h4> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |交叉染色法判断二分图|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bipartite</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{  </span><br><span class="line">    <span class="keyword">int</span> u, v;  </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;  </span><br><span class="line">    color[s] = <span class="number">1</span>;  </span><br><span class="line">    Q.push(s);  </span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) {  </span><br><span class="line">        u = Q.front();  </span><br><span class="line">        Q.pop();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) {  </span><br><span class="line">            v = G[u][i];  </span><br><span class="line">            <span class="keyword">if</span> (color[v] == <span class="number">0</span>) {  </span><br><span class="line">                color[v] = -color[u];  </span><br><span class="line">                Q.push(v);  </span><br><span class="line">            }  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (color[v] == color[u])  </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-4-2-匈牙利算法"><a href="#2-4-2-匈牙利算法" class="headerlink" title="2.4.2. 匈牙利算法"></a>2.4.2. 匈牙利算法</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |求解最大匹配问题|</span></span><br><span class="line"><span class="comment">    |递归实现|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];  </span><br><span class="line"><span class="keyword">bool</span> inpath[maxn];  <span class="comment">// 标记  </span></span><br><span class="line"><span class="keyword">int</span> match[maxn];    <span class="comment">// 记录匹配对象 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="built_in">memset</span>(match, <span class="number">-1</span>, <span class="keyword">sizeof</span>(match));  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) {  </span><br><span class="line">        G[i].clear();  </span><br><span class="line">    }  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findpath</span><span class="params">(<span class="keyword">int</span> k)</span> </span>{  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[k].size(); ++i) {  </span><br><span class="line">        <span class="keyword">int</span> v = G[k][i];  </span><br><span class="line">        <span class="keyword">if</span> (!inpath[v]) {  </span><br><span class="line">            inpath[v] = <span class="literal">true</span>;  </span><br><span class="line">            <span class="keyword">if</span> (match[v] == <span class="number">-1</span> || findpath(match[v])) { <span class="comment">// 递归  </span></span><br><span class="line">                match[v] = k; <span class="comment">// 即匹配对象是“k妹子”的  </span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            }  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hungary</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {  <span class="comment">// m为需要匹配的“妹子”数  </span></span><br><span class="line">        <span class="built_in">memset</span>(inpath, <span class="literal">false</span>, <span class="keyword">sizeof</span>(inpath)); <span class="comment">// 每次都要初始化  </span></span><br><span class="line">        <span class="keyword">if</span> (findpath(i)) cnt++;  </span><br><span class="line">    }  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |求解最大匹配问题|</span></span><br><span class="line"><span class="comment">    |dfs实现|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> v1, v2;  </span><br><span class="line"><span class="keyword">bool</span> Map[<span class="number">501</span>][<span class="number">501</span>];  </span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">501</span>];  </span><br><span class="line"><span class="keyword">int</span> link[<span class="number">501</span>];  </span><br><span class="line"><span class="keyword">int</span> result;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= v2; ++y) {  </span><br><span class="line">        <span class="keyword">if</span> (Map[x][y] &amp;&amp; !visit[y]) {  </span><br><span class="line">            visit[y] = <span class="literal">true</span>;  </span><br><span class="line">            <span class="keyword">if</span> (link[y] == <span class="number">0</span> || dfs(link[y])) {  </span><br><span class="line">                link[y] = x;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            } </span><br><span class="line">		} </span><br><span class="line">	}  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">()</span>  </span>{  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= v1; x++) {  </span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));  </span><br><span class="line">        <span class="keyword">if</span> (dfs(x))  </span><br><span class="line">            result++;  </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3. 动态规划"></a>3. 动态规划</h2><h3 id="3-1-背包问题"><a href="#3-1-背包问题" class="headerlink" title="3.1. 背包问题"></a>3.1. 背包问题</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |01背包|</span></span><br><span class="line"><span class="comment">    |完全背包|</span></span><br><span class="line"><span class="comment">	|多重背包|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 01背包：  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bag01</span><span class="params">(<span class="keyword">int</span> cost, <span class="keyword">int</span> weight)</span> </span>{  </span><br><span class="line">    <span class="keyword">for</span>(i = v; i &gt;= cost; --i)  </span><br><span class="line">    dp[i] = max(dp[i], dp[i - cost] + weight);  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 完全背包：  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(<span class="keyword">int</span> cost, <span class="keyword">int</span> weight)</span> </span>{  </span><br><span class="line">    <span class="keyword">for</span>(i = cost; i &lt;= v; ++i)  </span><br><span class="line">    dp[i] = max(dp[i], dp[i - cost] + weight);  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重背包：  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> cost, <span class="keyword">int</span> weight, <span class="keyword">int</span> amount)</span> </span>{  </span><br><span class="line">    <span class="keyword">if</span>(cost * amount &gt;= v)  </span><br><span class="line">        complete(cost, weight);  </span><br><span class="line">    <span class="keyword">else</span>{  </span><br><span class="line">        k = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span> (k &lt; amount){  </span><br><span class="line">            bag01(k * cost, k * weight);  </span><br><span class="line">            amount -= k;  </span><br><span class="line">            k += k;  </span><br><span class="line">        }  </span><br><span class="line">        bag01(cost * amount, weight * amount);  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-2-最长上升子序列（LIS）"><a href="#3-2-最长上升子序列（LIS）" class="headerlink" title="3.2. 最长上升子序列（LIS）"></a>3.2. 最长上升子序列（LIS）</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |最长上升子序列|</span></span><br><span class="line"><span class="comment">    |状态转移|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    状态转移dp[i] = max{1, dp[j] + 1 };  j&lt;i; a[j]&lt;a[i];</span></span><br><span class="line"><span class="comment">    d[i]是以i结尾的最长上升子序列</span></span><br><span class="line"><span class="comment">    与i之前的 每个a[j]&lt;a[i]的 j的位置的最长上升子序列+1后的值比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>{   <span class="comment">// 参考挑战程序设计入门经典;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i){  </span><br><span class="line">        dp[i] = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j){  </span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[i]){  </span><br><span class="line">                dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);  </span><br><span class="line">			}</span><br><span class="line">		} </span><br><span class="line">	}</span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    优化方法：</span></span><br><span class="line"><span class="comment">    dp[i]表示长度为i+1的上升子序列的最末尾元素  </span></span><br><span class="line"><span class="comment">    找到第一个比dp末尾大的来代替 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i){</span><br><span class="line">        dp[i] = INF;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {  </span><br><span class="line">        *lower_bound(dp, dp + n, a[i]) = a[i];  <span class="comment">// 返回一个指针  </span></span><br><span class="line">    }  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *lower_bound(dp, dp + n, INF) - dp;  </span><br><span class="line">}</span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    函数lower_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了一个不小于value的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-3-最长公共子序列（LCS）"><a href="#3-3-最长公共子序列（LCS）" class="headerlink" title="3.3. 最长公共子序列（LCS）"></a>3.3. 最长公共子序列（LCS）</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |求最长公共子序列|</span></span><br><span class="line"><span class="comment">    |递推形式|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) {  </span><br><span class="line">            <span class="keyword">if</span> (s1[i] == s2[j]) {  </span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;  </span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {  </span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);  </span><br><span class="line">            } </span><br><span class="line">        } </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h2><h3 id="4-1-kmp算法"><a href="#4-1-kmp算法" class="headerlink" title="4.1. kmp算法"></a>4.1. kmp算法</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |kmp算法|</span></span><br><span class="line"><span class="comment">    |字符串匹配|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="keyword">char</span> str[maxn], <span class="keyword">int</span> nextt[maxn])</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">    nextt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; m) {</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || str[j] == str[k]) {</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">            nextt[j] = k;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            k = nextt[k];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">(<span class="keyword">int</span> a[maxn], <span class="keyword">int</span> b[maxn])</span> </span>{    </span><br><span class="line">    <span class="keyword">int</span> nextt[maxm];    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;    </span><br><span class="line">    getnext(b, nextt);    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) {    </span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || a[i] == b[j]) { <span class="comment">// 母串不动，子串移动    </span></span><br><span class="line">            j++;    </span><br><span class="line">            i++;    </span><br><span class="line">        }    </span><br><span class="line">        <span class="keyword">else</span> {    </span><br><span class="line">            <span class="comment">// i不需要回溯了    </span></span><br><span class="line">            <span class="comment">// i = i - j + 1;    </span></span><br><span class="line">            j = nextt[j];    </span><br><span class="line">        }    </span><br><span class="line">        <span class="keyword">if</span> (j == m) {    </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - m + <span class="number">1</span>); <span class="comment">// 母串的位置减去子串的长度+1    </span></span><br><span class="line">            <span class="keyword">return</span>;    </span><br><span class="line">        }    </span><br><span class="line">    }    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-2-kmp扩展算法"><a href="#4-2-kmp扩展算法" class="headerlink" title="4.2. kmp扩展算法"></a>4.2. kmp扩展算法</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MM = <span class="number">100005</span>;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next[MM], extend[MM];    </span><br><span class="line"><span class="keyword">char</span> S[MM], T[MM];    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *T)</span> </span>{    </span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(T), a = <span class="number">0</span>;    </span><br><span class="line">    next[<span class="number">0</span>] = len;    </span><br><span class="line">    <span class="keyword">while</span>(a &lt; len - <span class="number">1</span> &amp;&amp; T[a] == T[a + <span class="number">1</span>]) a++;    </span><br><span class="line">    next[<span class="number">1</span>] = a;    </span><br><span class="line">    a = <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; len; k++) {    </span><br><span class="line">        <span class="keyword">int</span> p = a + next[a] - <span class="number">1</span>, L = next[k - a];    </span><br><span class="line">        <span class="keyword">if</span>((k - <span class="number">1</span>) + L &gt;= p) {    </span><br><span class="line">            <span class="keyword">int</span> j = (p - k + <span class="number">1</span>) &gt; <span class="number">0</span> ? (p - k + <span class="number">1</span>) : <span class="number">0</span>;    </span><br><span class="line">            <span class="keyword">while</span>(k + j &lt; len &amp;&amp; T[k + j] == T[j]) j++;    </span><br><span class="line">            next[k] = j;    </span><br><span class="line">            a = k;    </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            next[k] = L;    </span><br><span class="line">    }    </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetExtend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S, <span class="keyword">const</span> <span class="keyword">char</span> *T)</span> </span>{    </span><br><span class="line">    GetNext(T);    </span><br><span class="line">    <span class="keyword">int</span> slen = <span class="built_in">strlen</span>(S), tlen = <span class="built_in">strlen</span>(T), a = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">int</span> MinLen = slen &lt; tlen ? slen : tlen;    </span><br><span class="line">    <span class="keyword">while</span>(a &lt; MinLen &amp;&amp; S[a] == T[a]) a++;    </span><br><span class="line">    extend[<span class="number">0</span>] = a;     </span><br><span class="line">    a = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; slen; k++) {    </span><br><span class="line">        <span class="keyword">int</span> p = a + extend[a] - <span class="number">1</span>, L = next[k - a];    </span><br><span class="line">        <span class="keyword">if</span>((k - <span class="number">1</span>) + L &gt;= p) {    </span><br><span class="line">            <span class="keyword">int</span> j = (p - k + <span class="number">1</span>) &gt; <span class="number">0</span> ? (p - k + <span class="number">1</span>) : <span class="number">0</span>;    </span><br><span class="line">            <span class="keyword">while</span>(k + j &lt; slen &amp;&amp; j &lt; tlen &amp;&amp; S[k + j] == T[j]) j++;    </span><br><span class="line">            extend[k] = j;    </span><br><span class="line">            a = k;    </span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            extend[k] = L;    </span><br><span class="line">    }    </span><br><span class="line">}    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *s, <span class="keyword">int</span> len)</span></span>{    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)    </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; s[i] &lt;&lt; <span class="string">' '</span>;    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">}    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{    </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; S &gt;&gt; T) {    </span><br><span class="line">        GetExtend(S, T);    </span><br><span class="line">        show(next, <span class="built_in">strlen</span>(T));    </span><br><span class="line">        show(extend, <span class="built_in">strlen</span>(S));    </span><br><span class="line">    }    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-字典树"><a href="#5-字典树" class="headerlink" title="5. 字典树"></a>5. 字典树</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> {</span>  </span><br><span class="line">    <span class="keyword">int</span> cnt;  </span><br><span class="line">    Trie *next[maxn];  </span><br><span class="line">    Trie(){  </span><br><span class="line">        cnt = <span class="number">0</span>;  </span><br><span class="line">        <span class="built_in">memset</span>(next,<span class="number">0</span>,<span class="keyword">sizeof</span>(next));  </span><br><span class="line">    }  </span><br><span class="line">};  </span><br><span class="line"></span><br><span class="line">Trie *root;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *word)</span> </span>{  </span><br><span class="line">    Trie *tem = root;  </span><br><span class="line">    <span class="keyword">while</span>(*word != <span class="string">'\0'</span>) {  </span><br><span class="line">        <span class="keyword">int</span> x = *word - <span class="string">'a'</span>;  </span><br><span class="line">        <span class="keyword">if</span>(tem-&gt;next[x] == <span class="literal">NULL</span>)  </span><br><span class="line">            tem-&gt;next[x] = <span class="keyword">new</span> Trie;  </span><br><span class="line">        tem = tem-&gt;next[x];  </span><br><span class="line">        tem-&gt;cnt++;  </span><br><span class="line">        word++;  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">char</span> *word)</span> </span>{  </span><br><span class="line">    Trie *tem = root;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; word[i] != <span class="string">'\0'</span>; i++) {  </span><br><span class="line">        <span class="keyword">int</span> x = word[i]-<span class="string">'a'</span>;  </span><br><span class="line">        <span class="keyword">if</span>(tem-&gt;next[x] == <span class="literal">NULL</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        tem = tem-&gt;next[x];  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> tem-&gt;cnt;  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">char</span> *word, <span class="keyword">int</span> t)</span> </span>{  </span><br><span class="line">    Trie *tem = root;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; word[i] != <span class="string">'\0'</span>; i++) {  </span><br><span class="line">        <span class="keyword">int</span> x = word[i]-<span class="string">'a'</span>;  </span><br><span class="line">        tem = tem-&gt;next[x];  </span><br><span class="line">        (tem-&gt;cnt) -= t;  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)  </span><br><span class="line">        tem-&gt;next[i] = <span class="literal">NULL</span>;  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">int</span> n;  </span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">50</span>];  </span><br><span class="line">    <span class="keyword">char</span> str2[<span class="number">50</span>];  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)!=EOF) {  </span><br><span class="line">        root = <span class="keyword">new</span> Trie;  </span><br><span class="line">        <span class="keyword">while</span>(n--) {  </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s %s"</span>, str1, str2);  </span><br><span class="line">            <span class="keyword">if</span>(str1[<span class="number">0</span>] == <span class="string">'i'</span>) {</span><br><span class="line">                Insert(str2); </span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str1[<span class="number">0</span>] == <span class="string">'s'</span>) {  </span><br><span class="line">                <span class="keyword">if</span>(Search(str2))  </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"No\n"</span>);  </span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {  </span><br><span class="line">                <span class="keyword">int</span> t = Search(str2);  </span><br><span class="line">                <span class="keyword">if</span>(t)  </span><br><span class="line">                    Delete(str2, t);  </span><br><span class="line">            } </span><br><span class="line">        } </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="6-线段树"><a href="#6-线段树" class="headerlink" title="6. 线段树"></a>6. 线段树</h2><h3 id="6-1-点更新"><a href="#6-1-点更新" class="headerlink" title="6.1. 点更新"></a>6.1. 点更新</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">int</span> max, sum;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">node tree[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> p, q;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span><span class="comment">//m 是 树的标号</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    tree[m].left = l;</span><br><span class="line">    tree[m].right = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) {</span><br><span class="line">        tree[m].max = a[l];</span><br><span class="line">        tree[m].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(m &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    build(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    tree[m].max = max(tree[m &lt;&lt; <span class="number">1</span>].max, tree[m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].max);</span><br><span class="line">    tree[m].sum = tree[m &lt;&lt; <span class="number">1</span>].sum + tree[m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> a, <span class="keyword">int</span> val)</span><span class="comment">//a 是 节点位置， val 是 更新的值（加减的值）</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (tree[m].left == a &amp;&amp; tree[m].right == a) {</span><br><span class="line">        tree[m].max += val;</span><br><span class="line">        tree[m].sum += val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[m].left + tree[m].right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= mid) {</span><br><span class="line">        update(m &lt;&lt; <span class="number">1</span>, a, val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        update(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, a, val);</span><br><span class="line">    }</span><br><span class="line">    tree[m].max = max(tree[m &lt;&lt; <span class="number">1</span>].max, tree[m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].max);</span><br><span class="line">    tree[m].sum = tree[m &lt;&lt; <span class="number">1</span>].sum + tree[m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">querySum</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (l == tree[m].left &amp;&amp; r == tree[m].right) {</span><br><span class="line">        <span class="keyword">return</span> tree[m].sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[m].left + tree[m].right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) {</span><br><span class="line">        <span class="keyword">return</span> querySum(m &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) {</span><br><span class="line">        <span class="keyword">return</span> querySum(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> querySum(m &lt;&lt; <span class="number">1</span>, l, mid) + querySum(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryMax</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (l == tree[m].left &amp;&amp; r == tree[m].right) {</span><br><span class="line">        <span class="keyword">return</span> tree[m].max;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[m].left + tree[m].right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) {</span><br><span class="line">        <span class="keyword">return</span> queryMax(m &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) {</span><br><span class="line">        <span class="keyword">return</span> queryMax(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max(queryMax(m &lt;&lt; <span class="number">1</span>, l, mid), queryMax(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r));</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, n);  </span><br><span class="line">update(<span class="number">1</span>, a, b);  </span><br><span class="line">query(<span class="number">1</span>, a, b);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-2-区间更新"><a href="#6-2-区间更新" class="headerlink" title="6.2. 区间更新"></a>6.2. 区间更新</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,q;  </span><br><span class="line">ll anssum;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span>  </span><br><span class="line">    ll l, r;  </span><br><span class="line">    ll addv, sum;  </span><br><span class="line">}tree[maxn &lt;&lt; <span class="number">2</span>];  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{  </span><br><span class="line">    <span class="keyword">if</span>(tree[id].l &gt;= tree[id].r)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    tree[id].sum = tree[id &lt;&lt; <span class="number">1</span>].sum + tree[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{  </span><br><span class="line">    <span class="keyword">if</span>(tree[id].l &gt;= tree[id].r)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    <span class="keyword">if</span>(tree[id].addv){  </span><br><span class="line">        <span class="keyword">int</span> tmp = tree[id].addv;  </span><br><span class="line">        tree[id &lt;&lt; <span class="number">1</span>].addv += tmp;  </span><br><span class="line">        tree[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].addv += tmp;  </span><br><span class="line">        tree[id &lt;&lt; <span class="number">1</span>].sum += (tree[id &lt;&lt; <span class="number">1</span>].r - tree[id &lt;&lt; <span class="number">1</span>].l + <span class="number">1</span>) * tmp;  </span><br><span class="line">        tree[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum += (tree[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].r - tree[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l + <span class="number">1</span>) * tmp;  </span><br><span class="line">        tree[id].addv = <span class="number">0</span>;  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id, ll l, ll r)</span> </span>{  </span><br><span class="line">    tree[id].l = l;  </span><br><span class="line">    tree[id].r = r;  </span><br><span class="line">    tree[id].addv = <span class="number">0</span>;  </span><br><span class="line">    tree[id].sum = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(l == r) {  </span><br><span class="line">        tree[id].sum = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    }  </span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">    build(id &lt;&lt; <span class="number">1</span>, l, mid);  </span><br><span class="line">    build(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);  </span><br><span class="line">    maintain(id);  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateAdd</span><span class="params">(<span class="keyword">int</span> id,ll l,ll r,ll val)</span> </span>{  </span><br><span class="line">    <span class="keyword">if</span>(tree[id].l &gt;= l &amp;&amp; tree[id].r &lt;= r)  </span><br><span class="line">    {  </span><br><span class="line">        tree[id].addv += val;  </span><br><span class="line">        tree[id].sum += (tree[id].r - tree[id].l + <span class="number">1</span>) * val;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    }  </span><br><span class="line">    pushdown(id);  </span><br><span class="line">    ll mid = (tree[id].l + tree[id].r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)  </span><br><span class="line">        updateAdd(id &lt;&lt; <span class="number">1</span>, l, r, val);  </span><br><span class="line">    <span class="keyword">if</span>(mid &lt; r)  </span><br><span class="line">        updateAdd(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, val);  </span><br><span class="line">    maintain(id);  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> id, ll l, ll r)</span> </span>{  </span><br><span class="line">    <span class="keyword">if</span>(tree[id].l &gt;= l &amp;&amp; tree[id].r &lt;= r){  </span><br><span class="line">        anssum += tree[id].sum;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    }  </span><br><span class="line">    pushdown(id);  </span><br><span class="line">    ll mid = (tree[id].l + tree[id].r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)  </span><br><span class="line">        query(id &lt;&lt; <span class="number">1</span>, l, r);  </span><br><span class="line">    <span class="keyword">if</span>(mid &lt; r)  </span><br><span class="line">        query(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);  </span><br><span class="line">    maintain(id);  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);  </span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(t--) {  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;q);  </span><br><span class="line">        build(<span class="number">1</span>, <span class="number">1</span>, n);  </span><br><span class="line">        <span class="keyword">int</span> id;  </span><br><span class="line">        ll x, y;  </span><br><span class="line">        ll val;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, ++kase);  </span><br><span class="line">        <span class="keyword">while</span>(q--) {  </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;id);  </span><br><span class="line">            <span class="keyword">if</span>(id == <span class="number">0</span>) {  </span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>, &amp;x, &amp;y, &amp;val);  </span><br><span class="line">                updateAdd(<span class="number">1</span>, x + <span class="number">1</span>, y + <span class="number">1</span>, val);  </span><br><span class="line">            }  </span><br><span class="line">            <span class="keyword">else</span> {  </span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;x, &amp;y);  </span><br><span class="line">                anssum = <span class="number">0</span>;  </span><br><span class="line">                query(<span class="number">1</span>, x + <span class="number">1</span>, y + <span class="number">1</span>);  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, anssum);  </span><br><span class="line">            } </span><br><span class="line">        } </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="7-树状数组"><a href="#7-树状数组" class="headerlink" title="7. 树状数组"></a>7. 树状数组</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> t)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> t &amp; (-t);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> d)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (t &lt;= n){</span><br><span class="line">        a[t] += d;</span><br><span class="line">        t = t + lowbit(t);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> t)</span> </span>{</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">0</span>){</span><br><span class="line">        sum += a[t];</span><br><span class="line">        t = t - lowbit(t);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> t, k, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    k= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--){</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d);</span><br><span class="line">            insert(i, d);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, k++);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) {</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="string">"End"</span>)   <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="string">"Query"</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, getSum(y) - getSum(x - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str == <span class="string">"Add"</span>)</span><br><span class="line">                insert(x, y);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str == <span class="string">"Sub"</span>)</span><br><span class="line">                insert(x, -y);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求逆序对</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">		node[i].index = i;</span><br><span class="line">		node[i].v = a;</span><br><span class="line">	}</span><br><span class="line">	sort(node + <span class="number">1</span>, node + <span class="number">1</span> + n);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	{ </span><br><span class="line">		add(node[i].index);  <span class="comment">//离散化结果—— 下标等效于数值</span></span><br><span class="line">		ans += i - sum(node[i].index); <span class="comment">//得到之前有多少个比你大的数（逆序对）</span></span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="8-中国剩余定理（孙子定理）"><a href="#8-中国剩余定理（孙子定理）" class="headerlink" title="8. 中国剩余定理（孙子定理）"></a>8. 中国剩余定理（孙子定理）</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CRT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> m[], <span class="keyword">int</span> n)</span>  </span>{    </span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    </span><br><span class="line">        M *= m[i];    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  {    </span><br><span class="line">        <span class="keyword">int</span> x, y;    </span><br><span class="line">        <span class="keyword">int</span> Mi = M / m[i];    </span><br><span class="line">        extend_Euclid(Mi, m[i], x, y);    </span><br><span class="line">        ans = (ans + Mi * x * a[i]) % M;    </span><br><span class="line">    }    </span><br><span class="line">    <span class="keyword">if</span>(ans &lt; <span class="number">0</span>) ans += M;    </span><br><span class="line">    <span class="keyword">return</span> ans;    </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend_Euclid</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span>  </span>{  </span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) {  </span><br><span class="line">        x = <span class="number">1</span>;  </span><br><span class="line">        y = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    }  </span><br><span class="line">    extend_Euclid(b, a % b, x, y);  </span><br><span class="line">    <span class="keyword">int</span> tmp = x;  </span><br><span class="line">    x = y;  </span><br><span class="line">    y = tmp - (a / b) * y;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="9-最大流-最大权闭合子图"><a href="#9-最大流-最大权闭合子图" class="headerlink" title="9. 最大流/最大权闭合子图"></a>9. 最大流/最大权闭合子图</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从源点s向每个正权点连一条容量为权值的边，每个负权点向汇点t连一条容量为权值的绝对值的边，有向图原来的边容量全部为无限大。</span></span><br><span class="line"><span class="comment">//最大权闭合子图=（正权之和-不选的正权之和-要选的负权绝对值之和）=正权值和-最小割/最大流</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5010     <span class="comment">//课程</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 50100    <span class="comment">//用户</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> {</span>  </span><br><span class="line">    <span class="keyword">int</span> v, c, next;  </span><br><span class="line">    Edge(<span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> next): v(v), c(c), next(next) {}  </span><br><span class="line">    Edge(){}  </span><br><span class="line">}e[maxm * <span class="number">6</span> + maxn * <span class="number">2</span>];  </span><br><span class="line"><span class="keyword">int</span> p[maxn + maxm];  </span><br><span class="line"><span class="keyword">int</span> cnt, n, m, T;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{  </span><br><span class="line">    cnt = <span class="number">0</span>;  </span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span>(p));  </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>{  </span><br><span class="line">    e[cnt] = Edge(v, c, p[u]);  </span><br><span class="line">    p[u] = cnt++;  <span class="comment">// 顶点u的上一条相邻的边 </span></span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn + maxm];  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span>(d));  </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;  </span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">    q.push(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) {  </span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = p[u]; i != <span class="number">-1</span>; i = e[i].next) {  </span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;  </span><br><span class="line">            <span class="keyword">if</span>(e[i].c &gt; <span class="number">0</span> &amp;&amp; d[v] == <span class="number">-1</span>){  </span><br><span class="line">                <span class="comment">//printf("%d-&gt;%d(%d)\n", u, v, d[u] + 1);  </span></span><br><span class="line">                d[v] = d[u] + <span class="number">1</span>;  </span><br><span class="line">                q.push(v);  </span><br><span class="line">            }  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> d[T] != <span class="number">-1</span>;  </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span></span>{  </span><br><span class="line">    <span class="keyword">if</span>(u == T)</span><br><span class="line">        <span class="keyword">return</span> flow;  </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = p[u]; i != <span class="number">-1</span>; i = e[i].next){  </span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;  </span><br><span class="line">        <span class="keyword">if</span>(e[i].c &gt; <span class="number">0</span> &amp;&amp; d[v] == d[u] + <span class="number">1</span>){  </span><br><span class="line">            <span class="keyword">int</span> tmp = dfs(v, min(flow, e[i].c));  </span><br><span class="line">            e[i].c -= tmp;  </span><br><span class="line">            flow -= tmp;  </span><br><span class="line">            e[i^<span class="number">1</span>].c += tmp;  </span><br><span class="line">            res += tmp;  </span><br><span class="line">            <span class="keyword">if</span>(flow == <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">0</span>)  </span><br><span class="line">        d[u] = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(bfs()){  </span><br><span class="line">   <span class="comment">// printf("here!\n");  </span></span><br><span class="line">        res += dfs(<span class="number">0</span>, inf);  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{  </span><br><span class="line">    init();  </span><br><span class="line">    <span class="keyword">int</span> p, a, b, c, sum = <span class="number">0</span>;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);  </span><br><span class="line">    T = n + m + <span class="number">1</span>;<span class="comment">//汇点  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++){  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p);  </span><br><span class="line">        insert(i + m, T, p);  <span class="comment">//课程放右边</span></span><br><span class="line">        insert(T, i + m, <span class="number">0</span>);  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++){  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);  </span><br><span class="line">        sum += c;  </span><br><span class="line">        insert(i, a + m, inf);   </span><br><span class="line">        insert(a + m, i, <span class="number">0</span>);  </span><br><span class="line">        insert(i, b + m, inf);  </span><br><span class="line">        insert(b + m, i, <span class="number">0</span>);  </span><br><span class="line">        insert(<span class="number">0</span>, i, c);   <span class="comment">//用户放左边</span></span><br><span class="line">        insert(i, <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">    }  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum - dinic());  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="10-拓扑排序-AOE网络-关键路径"><a href="#10-拓扑排序-AOE网络-关键路径" class="headerlink" title="10. 拓扑排序/AOE网络/关键路径"></a>10. 拓扑排序/AOE网络/关键路径</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="comment">//vector&lt;int&gt; child;</span></span><br><span class="line">	<span class="keyword">int</span> id; </span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//Node graph[maxn]; </span></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxn];</span><br><span class="line"><span class="comment">//int e[maxn]; //边上活动最早开始时间 </span></span><br><span class="line"><span class="comment">//int l[maxn]; //边上活动最晚开始时间</span></span><br><span class="line"><span class="keyword">int</span> ve[maxn];   <span class="comment">//顶点上活动最早开始时间 </span></span><br><span class="line"><span class="keyword">int</span> vl[maxn];  <span class="comment">//顶点上活动最晚开始时间</span></span><br><span class="line"><span class="keyword">int</span> in[maxn];  <span class="comment">// 每个结点的入度，为0时入队</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TopologicalSort</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="built_in">memset</span>(ve, <span class="number">0</span>, <span class="keyword">sizeof</span>(ve));</span><br><span class="line">	<span class="comment">//memset(inq,0,sizeof(inq));</span></span><br><span class="line">	<span class="comment">/*先找出所有初始时入度为0的结点*/</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)  </span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>(in[i] == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			q.push(i);</span><br><span class="line">			<span class="comment">//s.push(i);</span></span><br><span class="line">			<span class="comment">//inq[i] = true;</span></span><br><span class="line">			<span class="comment">//ve[i] = 0; </span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/*每次将所有入度为0的结点入栈，拓扑序*/</span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> tmp = q.front();</span><br><span class="line">		q.pop();    </span><br><span class="line">		s.push(tmp); <span class="comment">// num++；</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; "tmp:" &lt;&lt; tmp &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Adj[tmp].size(); i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> id = Adj[tmp][i].id;</span><br><span class="line">			<span class="keyword">if</span>(--in[id] == <span class="number">0</span>) <span class="comment">//入度减为0 加入拓扑排序 </span></span><br><span class="line">			{</span><br><span class="line">				q.push(id);</span><br><span class="line">				<span class="comment">//s.push(i);</span></span><br><span class="line">				<span class="comment">//inq[i]=true;</span></span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(ve[tmp] + Adj[tmp][i].length &gt; ve[id]) <span class="comment">//更新ve值 </span></span><br><span class="line">				ve[id] = ve[tmp] + Adj[tmp][i].length;</span><br><span class="line">			</span><br><span class="line">		}</span><br><span class="line">	 } </span><br><span class="line">	 <span class="comment">//cout &lt;&lt; "size: " &lt;&lt; s.size() &lt;&lt; endl;</span></span><br><span class="line">	 <span class="keyword">if</span>(s.size() == N) </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	 <span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_path</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(TopologicalSort(N) == <span class="literal">false</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	 <span class="comment">/*寻找拓扑序列最后一个结点，即开始时间最晚的一个结点*/</span></span><br><span class="line">	 <span class="keyword">int</span> max = <span class="number">-1</span>, u = <span class="number">-1</span>;</span><br><span class="line">	 <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	 {</span><br><span class="line">	 	<span class="keyword">if</span>(ve[i] &gt; max)</span><br><span class="line">	   {</span><br><span class="line">	    	max = ve[i];</span><br><span class="line">	    	u = i;</span><br><span class="line">	   } </span><br><span class="line">	 }</span><br><span class="line">	  <span class="comment">//fill(vl, vl + maxn, INF); </span></span><br><span class="line">	  <span class="comment">//vl[u] = ve[u];</span></span><br><span class="line">	  fill(vl, vl + maxn, ve[u]); </span><br><span class="line">	  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ve[u]);</span><br><span class="line">	  </span><br><span class="line">	 <span class="comment">/*元素逐个出栈，即为逆拓扑序列，构造vl数组*/</span></span><br><span class="line">	 <span class="keyword">while</span>(!s.empty())</span><br><span class="line">	 {</span><br><span class="line">	 	<span class="keyword">int</span> tmp = s.top();</span><br><span class="line">	 	s.pop();</span><br><span class="line">	 	<span class="comment">//int min = INF, u;</span></span><br><span class="line">	 	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Adj[tmp].size(); i++)</span><br><span class="line">	 	{</span><br><span class="line">	 		<span class="keyword">int</span> id = Adj[tmp][i].id;</span><br><span class="line">	 		<span class="keyword">if</span>(vl[id] - Adj[tmp][i].length &lt; vl[tmp])</span><br><span class="line">	 		{</span><br><span class="line">	 			vl[tmp] = vl[id] - Adj[tmp][i].length;</span><br><span class="line">			 }</span><br><span class="line">		 }</span><br><span class="line">	 }</span><br><span class="line">	 <span class="comment">/*遍历邻接点每条边，计算每项活动的最早和最晚开始时间*/</span></span><br><span class="line">	 <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	 {</span><br><span class="line">	 	<span class="keyword">for</span>(<span class="keyword">int</span> j = Adj[i].size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">	 	{</span><br><span class="line">	 		<span class="keyword">int</span> id = Adj[i][j].id;</span><br><span class="line">	 		<span class="keyword">int</span> e = ve[i];</span><br><span class="line">	 		<span class="keyword">int</span> l = vl[id]-Adj[i][j].length;</span><br><span class="line">	 		<span class="keyword">if</span>(e == l) </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d-&gt;%d\n"</span>, i, id); </span><br><span class="line">		 }</span><br><span class="line">	 }</span><br><span class="line"> } </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M) != EOF)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> v, w, len;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">		Adj[i].clear();</span><br><span class="line">		<span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span>(in));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;v, &amp;w, &amp;len);</span><br><span class="line">			Node tmp;</span><br><span class="line">			tmp.id = w;</span><br><span class="line">			tmp.length = len;</span><br><span class="line">			Adj[v].push_back(tmp); <span class="comment">//有向图只要添加单向边即可 </span></span><br><span class="line">			in[w]++; </span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">while</span>(!s.empty())</span><br><span class="line">		s.pop();</span><br><span class="line">		calc_path(N);</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "end!!" &lt;&lt; endl;</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="11-强连通分量"><a href="#11-强连通分量" class="headerlink" title="11. 强连通分量"></a>11. 强连通分量</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">} tu[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N];</span><br><span class="line"><span class="keyword">int</span> ip;</span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N];<span class="comment">///dfn[]表示深搜的步数，low[u]表示u或u的子树能够追溯到的最早的栈中节点的次序号</span></span><br><span class="line"><span class="keyword">int</span> sccno[N];<span class="comment">///缩点数组，表示某个点对应的缩点值</span></span><br><span class="line"><span class="keyword">int</span> step;</span><br><span class="line"><span class="keyword">int</span> scc_cnt;<span class="comment">///强连通分量个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ip=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    tu[ip].to = v;</span><br><span class="line">    tu[ip].next = head[u];</span><br><span class="line">    head[u] = ip++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; scc[N];<span class="comment">///得出来的缩点，scc[i]里面存i这个缩点具体缩了哪些点</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    dfn[u] = low[u] = ++step;</span><br><span class="line">    S.push(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = tu[i].next)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> v = tu[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v])</span><br><span class="line">        {</span><br><span class="line">            dfs(v);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!sccno[v])</span><br><span class="line">            low[u] = min(low[u], dfn[v]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (low[u] == dfn[u])</span><br><span class="line">    {</span><br><span class="line">        scc_cnt += <span class="number">1</span>;</span><br><span class="line">        scc[scc_cnt].clear();</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> x = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            <span class="keyword">if</span> (sccno[x] != scc_cnt) </span><br><span class="line">				scc[scc_cnt].push_back(x);</span><br><span class="line">            sccno[x] = scc_cnt;</span><br><span class="line">            <span class="keyword">if</span> (x == u) </span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(sccno, <span class="number">0</span>, <span class="keyword">sizeof</span>(sccno));</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    step = scc_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) </span><br><span class="line">			dfs(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="12-日期与星期-蔡勒公式"><a href="#12-日期与星期-蔡勒公式" class="headerlink" title="12. 日期与星期/蔡勒公式"></a>12. 日期与星期/蔡勒公式</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDayofWeek</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">1</span> || m == <span class="number">2</span>) {</span><br><span class="line">        m += <span class="number">12</span>;</span><br><span class="line">        y--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (d + <span class="number">2</span> * m + <span class="number">3</span> * (m + <span class="number">1</span>) / <span class="number">5</span> + y + y / <span class="number">4</span> - y / <span class="number">100</span> + y / <span class="number">400</span> + <span class="number">1</span>) % <span class="number">7</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://blog.csdn.net/qq_32265245/article/details/53046750" target="_blank" rel="noopener">ACM算法模板</a></p>
</li>
<li><p><a href="https://blog.csdn.net/m0_38033475/article/details/80173037" target="_blank" rel="noopener">dinic求最大权闭合子图</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_42584977/article/details/92001428" target="_blank" rel="noopener">拓扑排序+AOE网络+关键路径</a></p>
</li>
<li><p><a href="https://blog.csdn.net/martinue/article/details/51315574" target="_blank" rel="noopener">tarjan模板</a></p>
</li>
<li><p><a href="https://zh.wikipedia.org/wiki/%E8%94%A1%E5%8B%92%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener">蔡勒公式</a></p>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><iframe src="/donate/?AliPayQR=/img/AliPayQR.jpg&amp;WeChatQR=/img/WeChatQR.png&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://hytu99.github.io/code-template/" data-id="ck52l55kq000foku7192vrbvh" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABzklEQVR42u3awU7DMBAE0P7/TxcJcUCChBlv4hbp+VS1NH3msFrv+PGI1/NznX/6c02eOVq4uLhj7vN0HT36Wa6jb+UGXFzc/dzzQjPfzNGnuQEXF/c9uXm7k3cpuLi4/517VJLWcLi4uO/PzQ8t523N+faSDVx2VsPFxR1w24HpHa9vnO/i4uKW3LWhZztCnf/u13NwcXG3cJNmJRmDrjU3a8chXFzcu7l50UnanfaYlGz4lxKGi4u7hXv+oLytyduXgvj9L3Fxcbdw89B0foxpI5n6YhYuLu5F3CLaDH4sOcwk5ezwybi4uNu5beDRXqHIy1lUcXFxcbdw23xzbVKRx7ePvL7i4uJeys2LWvtOG7vWJRIXF/c27vyIsvZ67R1cXNyd3LVoJI9A2isXo+QHFxd3zM0vZhUh6DhuqQMVXFzcS7lrg8t8ODIJa3FxcV/Lza9RFrHHeESLi4v7Wu7kctV8pFJsGBcXdwu3LSj1iHMQry6Gr7i4uBdx8+KV0Nui1o5ocXFxd3Lz4tU2Q+3h549/By4u7ptx2wtVk/Hr4aEIFxf37bntd9tGChcX97XctUtUbYA6GcTg4uLu5E4GpvnopI1dcXFxX8T9ADZjbMOdoG3VAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/保研/">保研</a><a href="/tags/机试/">机试</a><a href="/tags/编程/">编程</a><a href="/tags/算法/">算法</a></div><div class="post-nav"><a class="pre" href="/deep-code-search/">【论文阅读】Deep Code Search</a><a class="next" href="/first-article/">终于弄好博客啦</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://hytu99.github.io/code-template/';
    this.page.identifier = 'code-template/';
    this.page.title = '机试模板整理';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//ustcthy.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//ustcthy.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://ustcthy.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Paper-Reading/">Paper Reading</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术总结/">技术总结</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/程序设计/">程序设计</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/deep-learning/" style="font-size: 15px;">deep learning</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/学习笔记/" style="font-size: 15px;">学习笔记</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/code-search/" style="font-size: 15px;">code search</a> <a href="/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/tags/nlp/" style="font-size: 15px;">nlp</a> <a href="/tags/保研/" style="font-size: 15px;">保研</a> <a href="/tags/机试/" style="font-size: 15px;">机试</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/ml-svm/">【机器学习笔记】4. Support Vector Machine & Lagrange Duality</a></li><li class="post-list-item"><a class="post-list-link" href="/ml-naive-bayes/">【机器学习笔记】3. Naive Bayes & Logistic Regression</a></li><li class="post-list-item"><a class="post-list-link" href="/docker/">Docker入门总结</a></li><li class="post-list-item"><a class="post-list-link" href="/ml-gradient-descent/">【机器学习笔记】2. Gradient Descent</a></li><li class="post-list-item"><a class="post-list-link" href="/ml-linear-regression/">【机器学习笔记】1. Linear Regression</a></li><li class="post-list-item"><a class="post-list-link" href="/deep-code-search/">【论文阅读】Deep Code Search</a></li><li class="post-list-item"><a class="post-list-link" href="/code-template/">机试模板整理</a></li><li class="post-list-item"><a class="post-list-link" href="/first-article/">终于弄好博客啦</a></li><li class="post-list-item"><a class="post-list-link" href="/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//ustcthy.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">山尤远.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>